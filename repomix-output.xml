This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
Picklet/
  Extensions/
    UIImage+FixOrientation.swift
    UIImage+FlippedHorizontally.swift
    UIImage+InvertedMask.swift
    UIImage+Normalized.swift
    UIImage+PixelBuffer.swift
    UIImage+ResizedAspectFit.swift
    UIImage+Rotate.swift
  Models/
    Clothing.swift
    ClothingImage.swift
    LocationManager.swift
    Weather.swift
  Preview Content/
    Preview Assets.xcassets/
      Contents.json
  Resources/
    Assets.xcassets/
      AccentColor.colorset/
        Contents.json
      AppIcon.appiconset/
        Contents.json
      Contents.json
  Services/
    CoreMLService.swift
    ImageProcessor.swift
    SupabaseService.swift
    WeatherService.swift
  Utilities/
    ImagePicker.swift
  ViewModels/
    ClothingViewModel.swift
    LibraryPickerViewModel.swift
    LoginViewModel.swift
  Views/
    Capture/
      Camera/
        CameraPreviewController.swift
        CameraPreviewView.swift
        CameraSquarePreviewView.swift
      Library/
        LibraryPickerView.swift
        PhotoLibraryPickerView.swift
      CaptureOrLibraryView.swift
      ModeSwitchBarView.swift
    Components/
      PrimaryActionButton.swift
    Dock/
      ClothingDockView.swift
    Edit/
      Image/
        ImageEditView.swift
        ImageView.swift
      ClothingEditView.swift
    ClothingCropEditView.swift
    ClothingCropPreviewView.swift
    ClothingDetailView.swift
    ClothingItemView.swift
    ClothingListView.swift
    EditableImageSet.swift
    LocationTestView.swift
    LoginView.swift
    MainTabView.swift
    MaskEditCanvasView.swift
    SettingsView.swift
    WeatherLoaderView.swift
    WeatherView.swift
  Info.plist
  PickletApp.swift
Picklet.xcodeproj/
  project.xcworkspace/
    xcshareddata/
      swiftpm/
        Package.resolved
      WorkspaceSettings.xcsettings
    xcuserdata/
      reiji.xcuserdatad/
        Bookmarks/
          bookmarks.plist
        WorkspaceSettings.xcsettings
    contents.xcworkspacedata
  xcshareddata/
    xcschemes/
      MyApp.xcscheme
  xcuserdata/
    reiji.xcuserdatad/
      xcdebugger/
        Breakpoints_v2.xcbkptlist
      xcschemes/
        xcschememanagement.plist
  project.pbxproj
PickletTests/
  PickletTests.swift
PickletUITests/
  PickletUITests.swift
  PickletUITestsLaunchTests.swift
.gitattributes
.gitignore
.swiftlint.yml
run_app.sh
run_device.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Picklet/Extensions/UIImage+FixOrientation.swift">
//
//  UIImage+FixOrientation.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import UIKit

extension UIImage {
  /// ÁîªÂÉè„ÅÆ‰∏ä‰∏ãÂ∑¶Âè≥„ÅÆÂêë„Åç„Çí .up „Å´Ê≠£Ë¶èÂåñ„Åô„Çã
  func fixedOrientation() -> UIImage {
    if imageOrientation == .up {
      return self
    }

    UIGraphicsBeginImageContextWithOptions(size, false, scale)
    draw(in: CGRect(origin: .zero, size: size))
    let normalizedImage = UIGraphicsGetImageFromCurrentImageContext()!
    UIGraphicsEndImageContext()
    return normalizedImage
  }
}
</file>

<file path="Picklet/Extensions/UIImage+FlippedHorizontally.swift">
//
//  UIImage+FlippedHorizontally.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import UIKit

extension UIImage {
  func flippedHorizontally() -> UIImage? {
    UIGraphicsBeginImageContextWithOptions(size, false, scale)
    let context = UIGraphicsGetCurrentContext()
    context?.translateBy(x: 0, y: size.height)
    context?.scaleBy(x: 1, y: -1)
    draw(in: CGRect(origin: .zero, size: size))
    let flippedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return flippedImage
  }
}
</file>

<file path="Picklet/Extensions/UIImage+InvertedMask.swift">
//
//  UIImage+InvertedMask.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import CoreImage
import UIKit

extension UIImage {
  func invertedMask() -> UIImage? {
    guard let ciImage = CIImage(image: self) else { return nil }

    let filter = CIFilter(name: "CIColorInvert")
    filter?.setValue(ciImage, forKey: kCIInputImageKey)

    guard let outputImage = filter?.outputImage else { return nil }
    let context = CIContext()
    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {
      return UIImage(cgImage: cgImage)
    }
    return nil
  }
}
</file>

<file path="Picklet/Extensions/UIImage+Normalized.swift">
//
//  UIImage+Normalized.swift
//  MyApp
//
//  Created by al dente on 2025/04/29.
//

import UIKit

extension UIImage {
  func normalized() -> UIImage {
    if self.imageOrientation == .up {
      return self  // ÂïèÈ°å„Å™„Åó
    }

    UIGraphicsBeginImageContextWithOptions(self.size, false, self.scale)
    self.draw(in: CGRect(origin: .zero, size: self.size))
    let normalizedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return normalizedImage ?? self
  }
}
</file>

<file path="Picklet/Extensions/UIImage+PixelBuffer.swift">
//
//  UIImage+PixelBuffer.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import UIKit

extension UIImage {
  func pixelBuffer(width: Int, height: Int) -> CVPixelBuffer? {
    let attrs =
      [
        kCVPixelBufferCGImageCompatibilityKey: true,
        kCVPixelBufferCGBitmapContextCompatibilityKey: true,
      ] as CFDictionary
    var pixelBuffer: CVPixelBuffer?

    let status = CVPixelBufferCreate(
      kCFAllocatorDefault,
      width,
      height,
      kCVPixelFormatType_32ARGB,
      attrs,
      &pixelBuffer)

    guard status == kCVReturnSuccess, let buffer = pixelBuffer else { return nil }

    CVPixelBufferLockBaseAddress(buffer, .readOnly)
    let context = CGContext(
      data: CVPixelBufferGetBaseAddress(buffer),
      width: width,
      height: height,
      bitsPerComponent: 8,
      bytesPerRow: CVPixelBufferGetBytesPerRow(buffer),
      space: CGColorSpaceCreateDeviceRGB(),
      bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue)
    guard let cgImage = self.cgImage else { return nil }

    context?.saveGState()
    context?.translateBy(x: 0, y: CGFloat(height))
    context?.scaleBy(x: 1.0, y: -1.0)  // ‰∏ä‰∏ãÂèçËª¢„ÅßÊ≠£„Åó„ÅÑÊñπÂêë„Å´ÊèèÁîª„Åï„Çå„Çã
    context?.draw(cgImage, in: CGRect(x: 0, y: 0, width: width, height: height))
    context?.restoreGState()

    CVPixelBufferUnlockBaseAddress(buffer, .readOnly)

    return buffer
  }

  convenience init?(pixelBuffer: CVPixelBuffer) {
    let ciImage = CIImage(cvPixelBuffer: pixelBuffer)
    let context = CIContext()
    guard let cgImage = context.createCGImage(ciImage, from: ciImage.extent) else { return nil }
    self.init(cgImage: cgImage)
  }
}
</file>

<file path="Picklet/Extensions/UIImage+ResizedAspectFit.swift">
//
//  UIImage+Resized.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import UIKit

extension UIImage {
  /// ÂÖÉÁîªÂÉè„Çí„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„Çí‰øù„Å£„Åü„Åæ„Åæ„É™„Çµ„Ç§„Ç∫„Åó„ÄÅÈÄèÊòé„Å™ËÉåÊôØ„ÅßÊ≠£ÊñπÂΩ¢„Å´„Éë„Éá„Ç£„É≥„Ç∞„Åô„Çã
  func resizedAspectFitWithTransparentPadding(to targetSize: CGSize) -> UIImage? {
    // 1. ÂÖÉÁîªÂÉè„Å®„Çø„Éº„Ç≤„ÉÉ„Éà„Çµ„Ç§„Ç∫„ÅÆÊØîÁéá„ÇíË®àÁÆó
    let widthRatio = targetSize.width / size.width
    let heightRatio = targetSize.height / size.height

    // 2. Á∏¶Ê®™„ÅÆÂ∞è„Åï„ÅÑÊñπ„Å´Âêà„Çè„Åõ„Å¶„Çπ„Ç±„Éº„É´
    let scaleFactor = min(widthRatio, heightRatio)

    // 3. „É™„Çµ„Ç§„Ç∫Âæå„ÅÆÁîªÂÉè„Çµ„Ç§„Ç∫„ÇíÊ±∫ÂÆö
    let resizedSize = CGSize(
      width: size.width * scaleFactor,
      height: size.height * scaleFactor
    )

    // 4. ÊèèÁîª„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Çí„Çø„Éº„Ç≤„ÉÉ„Éà„Çµ„Ç§„Ç∫„Åß‰ΩúÊàêÔºàËÉåÊôØ„ÅØÈÄèÊòéÔºâ
    UIGraphicsBeginImageContextWithOptions(targetSize, false, scale)

    // 5. „É™„Çµ„Ç§„Ç∫Âæå„ÅÆÁîªÂÉè„Çí‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
    let origin = CGPoint(
      x: (targetSize.width - resizedSize.width) / 2,
      y: (targetSize.height - resizedSize.height) / 2
    )
    self.draw(in: CGRect(origin: origin, size: resizedSize))

    // 6. „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Åã„ÇâÊñ∞„Åó„ÅÑUIImage„ÇíÂèñ„ÇäÂá∫„Åô
    let resultImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return resultImage
  }
  /// ÂÖÉÁîªÂÉè„Çµ„Ç§„Ç∫„Å´„Éû„Çπ„ÇØ„Çí‰∏≠Â§ÆÂêà„Çè„Åõ„Åß„É™„Çµ„Ç§„Ç∫„Åô„Çã
  func resizedMaskCentered(to originalSize: CGSize) -> UIImage? {
    UIGraphicsBeginImageContextWithOptions(originalSize, false, scale)

    let maskSize = self.size.width  // 1024ÂâçÊèê
    let targetLongSide = max(originalSize.width, originalSize.height)
    let scaleFactor = targetLongSide / maskSize

    let newMaskSize = CGSize(
      width: self.size.width * scaleFactor,
      height: self.size.height * scaleFactor
    )

    let origin = CGPoint(
      x: (originalSize.width - newMaskSize.width) / 2,
      y: (originalSize.height - newMaskSize.height) / 2
    )

    self.draw(in: CGRect(origin: origin, size: newMaskSize))

    let resizedMask = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return resizedMask
  }
}
</file>

<file path="Picklet/Extensions/UIImage+Rotate.swift">
//
//  UIImage+Rotate.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import UIKit

extension UIImage {
  /// ‰ªªÊÑè„ÅÆËßíÂ∫¶ÔºàÂ∫¶Êï∞Ôºâ„ÅßÁîªÂÉè„ÇíÂõûËª¢„Åô„Çã
  func rotated(byDegrees degrees: CGFloat) -> UIImage? {
    let radians = degrees * (.pi / 180)
    let newSize = CGRect(origin: .zero, size: size)
      .applying(CGAffineTransform(rotationAngle: radians))
      .integral.size

    UIGraphicsBeginImageContextWithOptions(newSize, false, scale)
    guard let context = UIGraphicsGetCurrentContext(), let cgImage = self.cgImage else {
      return nil
    }

    context.translateBy(x: newSize.width / 2, y: newSize.height / 2)
    context.rotate(by: radians)
    context.scaleBy(x: 1.0, y: -1.0)  // UIKit„ÅÆ‰∏ä‰∏ãÂèçËª¢Ë£úÊ≠£

    context.draw(
      cgImage,
      in: CGRect(
        x: -size.width / 2, y: -size.height / 2,
        width: size.width, height: size.height))

    let rotatedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return rotatedImage
  }
}
</file>

<file path="Picklet/Models/Clothing.swift">
//
//  Clothing.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

// Models/Clothing.swift
import Foundation

struct Clothing: Codable, Identifiable, Equatable {
  let id: UUID
  let user_id: UUID
  var name: String
  var category: String
  var color: String
  let created_at: String
  let updated_at: String
}
</file>

<file path="Picklet/Models/ClothingImage.swift">
//
//  ClothingImage.swift
//  MyApp
//
//  Created by al dente on 2025/04/27.
//

import Foundation

struct ClothingImage: Identifiable, Codable {
  let id: UUID
  let clothing_id: UUID
  let user_id: UUID
  let original_url: String
  let mask_url: String?
  let result_url: String?
  let created_at: String
  let updated_at: String
}
</file>

<file path="Picklet/Models/LocationManager.swift">
//
//  LocationManager.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import CoreLocation
import SwiftUI

class LocationManager: NSObject, ObservableObject, CLLocationManagerDelegate {
  private let locationManager = CLLocationManager()

  @Published var currentLocation: CLLocation?
  @Published var placemark: CLPlacemark?
  @Published var locationError: Error?

  override init() {
    super.init()
    locationManager.delegate = self
    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters
    locationManager.requestWhenInUseAuthorization()
    locationManager.startUpdatingLocation()
  }

  func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    guard let location = locations.first else { return }
    self.currentLocation = location

    let geocoder = CLGeocoder()
    geocoder.reverseGeocodeLocation(location) { placemarks, error in
      if let error = error {
        self.locationError = error
        return
      }
      self.placemark = placemarks?.first
    }
  }

  func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
    self.locationError = error
  }
}
</file>

<file path="Picklet/Models/Weather.swift">
//
//  Weather.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

struct Weather: Codable {
  let city: String
  let date: String  // yyyy-MM-dd
  let temperature: Double
  let condition: String  // Ë°®Á§∫Áî®ÔºàÊó•Êú¨Ë™û: Êõá„Çä„Å™„Å©Ôºâ
  let icon: String  // OpenWeather„ÅÆ„Ç¢„Ç§„Ç≥„É≥Âêç
  let updated_at: String  // ISO8601ÂΩ¢Âºè„ÅÆÊó•ÊôÇÔºà„Ç≠„É£„ÉÉ„Ç∑„É•„ÅÆÊúâÂäπÊÄßÂà§ÂÆö„Å´„ÇÇ‰Ωø„Åà„ÇãÔºâ
}
</file>

<file path="Picklet/Preview Content/Preview Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Picklet/Resources/Assets.xcassets/AccentColor.colorset/Contents.json">
{
  "colors": [
    {
      "color": {
        "color-space": "srgb",
        "components": {
          "red": "0.0",
          "green": "0.478431",
          "blue": "1.0",
          "alpha": "1.0"
        }
      },
      "idiom": "universal"
    }
  ],
  "info": {
    "author": "xcode",
    "version": 1
  }
}
</file>

<file path="Picklet/Resources/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "filename" : "picklet.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Picklet/Resources/Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Picklet/Services/CoreMLService.swift">
//
//  CoreMLService.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import CoreML
import SwiftUI

class CoreMLService {
  static let shared = CoreMLService()

  private let model: ISNet

  init() {
    self.model = try! ISNet(configuration: MLModelConfiguration())
  }

  func processImageSet(imageSet: EditableImageSet?) async -> EditableImageSet? {
    // ‚ë† imageSetËá™‰Ωì„ÅÆÂ≠òÂú®„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    guard var set = imageSet else {
      print("‚ùå imageSet is nil")
      return nil
    }

    // ‚ë° original „Åå nil „Å™„Çâ URL „Åã„Çâ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
    if set.original == nil,
      let urlStr = set.originalUrl,
      let url = URL(string: urlStr)
    {
      do {
        let (data, _) = try await URLSession.shared.data(from: url)
        if let image = UIImage(data: data) {
          set.original = image
        } else {
          print("‚ùå failed to decode image from data")
          return nil
        }
      } catch {
        print("‚ùå failed to download image:", error)
        return nil
      }
    }

    // ‚ë¢ original „Åå still nil „ÅÆÂ†¥Âêà ‚Üí Âá¶ÁêÜ‰∏çÂèØ
    guard let original = set.original else {
      print("‚ùå original image not available")
      return nil
    }

    // ‚ë£ CoreML „Å´„Çà„Çã„Éû„Çπ„ÇØÊé®Ë´ñ
    guard let mask = await CoreMLService.shared.predictMask(for: original) else {
      print("‚ùå mask prediction failed")
      return nil
    }

    // ‚ë§ „Éû„Çπ„ÇØ„Çí‰Ωø„Å£„Å¶Âàá„ÇäÊäú„ÅçÁîªÂÉè„ÇíÁîüÊàê
    guard let result = ImageProcessor.applyMask(original: original, mask: mask) else {
      print("‚ùå mask application failed")
      return nil
    }

    // ‚ë• Âä†Â∑•ÁµêÊûú„Çí‰øùÂ≠ò„Åó„Å¶Ëøî„Åô
    set.mask = mask
    set.result = result
    return set
  }

  func processImage(image: UIImage) async -> UIImage? {
    // 1. Êé®Ë´ñ
    guard let mask = await CoreMLService.shared.predictMask(for: image) else {
      print("‚ùå mask prediction failed")
      return nil
    }

    guard let result = ImageProcessor.applyMask(original: image, mask: mask) else {
      print("‚ùå mask application failed")
      return nil
    }
    return result
  }

  func predictMask(
    for image: UIImage,
    flipHorizontally: Bool = true
  ) async -> UIImage? {
    let targetSize = CGSize(width: 1024, height: 1024)

    // 1. Êé®Ë´ñÁî®„Å´„É™„Çµ„Ç§„Ç∫
    guard let resizedInput = image.resizedAspectFitWithTransparentPadding(to: targetSize),
      let pixelBuffer = resizedInput.pixelBuffer(
        width: Int(targetSize.width), height: Int(targetSize.height))
    else {
      print("‚ùå pixelBufferÁîüÊàêÂ§±Êïó")
      return nil
    }

    do {
      // 2. Êé®Ë´ñ
      let output = try model.prediction(x_1: pixelBuffer)
      guard var maskImage = UIImage(pixelBuffer: output.activation_out) else {
        print("‚ùå „Éû„Çπ„ÇØÁîªÂÉè‰ΩúÊàêÂ§±Êïó")
        return nil
      }

      // ---„Åì„Åì„Åã„Çâ„Éû„Çπ„ÇØÂä†Â∑•---

      // 4. „Éû„Çπ„ÇØ„ÇíÂÖÉÁîªÂÉè„Çµ„Ç§„Ç∫„Å´„É™„Çµ„Ç§„Ç∫ÔºàÂÖÉÁîªÂÉè„Å®Âêå„ÅòÔºâ
      guard let resizedMask = maskImage.resizedMaskCentered(to: image.size) else {
        print("‚ùå „Éû„Çπ„ÇØ„É™„Çµ„Ç§„Ç∫Â§±Êïó")
        return nil
      }

      maskImage = resizedMask

      // 5. „Éû„Çπ„ÇØ„ÇíÂ∑¶Âè≥ÂèçËª¢ÔºàÂøÖË¶Å„Å™„ÇâÔºâ
      if flipHorizontally {
        maskImage = maskImage.flippedHorizontally() ?? maskImage
      }

      // 6. „Éû„Çπ„ÇØ„ÇíÁôΩÈªíÂèçËª¢
      guard let invertedMask = maskImage.invertedMask() else {
        print("‚ùå „Éû„Çπ„ÇØÁôΩÈªíÂèçËª¢Â§±Êïó")
        return nil
      }

      // ---„Éû„Çπ„ÇØÂä†Â∑•„Åì„Åì„Åæ„Åß---

      return invertedMask

    } catch {
      print("‚ùå Êé®Ë´ñÂ§±Êïó: \(error.localizedDescription)")
      return nil
    }
  }

}
</file>

<file path="Picklet/Services/ImageProcessor.swift">
//
//  ImageProcessor.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import CoreImage
import UIKit

enum ImageProcessor {
  /// CIImage„Åß„Éû„Çπ„ÇØÁîªÂÉè„Çí„Ç¢„É´„Éï„Ç°„Å´Â§âÊèõ ‚Üí ÂêàÊàê
  static func applyMask(original: UIImage, mask: UIImage) -> UIImage? {
    guard let ciOriginal = CIImage(image: original),
      let ciMask = CIImage(image: mask)
    else { return nil }

    let alphaMask =
      ciMask
      .applyingFilter("CIColorInvert")
      .applyingFilter("CIMaskToAlpha")

    let composited =
      ciOriginal
      .applyingFilter(
        "CIBlendWithAlphaMask",
        parameters: [
          "inputMaskImage": alphaMask
        ])

    let context = CIContext()
    guard let output = context.createCGImage(composited, from: ciOriginal.extent) else {
      return nil
    }

    return UIImage(cgImage: output)
  }

  /// ÂÆåÊàêÁîªÂÉè„Å®„Éû„Çπ„ÇØ„ÇíÂêàÊàê„Åó„Å¶„ÄÅ„Éû„Çπ„ÇØÁØÑÂõ≤„ÇíÈªí„ÅèÂº∑Ë™ø„Åô„Çã„Éì„Ç∏„É•„Ç¢„É©„Ç§„Ç∫ÁîªÂÉè„Çí‰Ωú„Çã
  static func visualizeMaskOnOriginal(original: UIImage, mask: UIImage) -> UIImage? {
    guard let ciOriginal = CIImage(image: original),
      let ciMask = CIImage(image: mask)
    else {
      return nil
    }

    // „Éû„Çπ„ÇØ„ÅÆÁôΩ„ÅÑÈÉ®ÂàÜ„Å†„Åë„ÇíÈÄèÊòé„Å´„Åô„ÇãÔºà„Éû„Çπ„ÇØ„ÅåÈªí„ÅÑ„Å®„Åì„Çç„ÅåÊÆã„ÇãÔºâ
    let alphaMask =
      ciMask
      .applyingFilter("CIColorInvert")
      .applyingFilter("CIMaskToAlpha")

    let maskedImage =
      ciOriginal
      .applyingFilter(
        "CIBlendWithAlphaMask",
        parameters: [
          "inputMaskImage": alphaMask
        ]
      )
      .applyingFilter(
        "CIColorControls",
        parameters: [
          "inputBrightness": -1.0  // Èªí„Åè„Åô„Çã
        ])

    let context = CIContext()
    guard let output = context.createCGImage(maskedImage, from: ciOriginal.extent) else {
      return nil
    }

    return UIImage(cgImage: output)
  }

}
</file>

<file path="Picklet/Services/SupabaseService.swift">
//
//  SupabaseService.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import Foundation
import PostgREST
import Storage
import Supabase
// Services/SupabaseService.swift
import SwiftUI
import UIKit

extension PostgrestResponse {
  func decoded<U: Decodable>(to type: U.Type) throws -> U {
    let decoder = JSONDecoder()
    return try decoder.decode(U.self, from: self.data)
  }
}

class SupabaseService {
  @AppStorage("isLoggedIn") var isLoggedIn = false

  static let shared = SupabaseService()

  internal let client: SupabaseClient
  private let storageBucketName = "clothes-images"

  private init() {
    guard
      let urlString = Bundle.main.object(forInfoDictionaryKey: "SUPABASE_URL") as? String,
      let key = Bundle.main.object(forInfoDictionaryKey: "SUPABASE_KEY") as? String,
      let url = URL(string: urlString)
    else {
      fatalError("‚ùå Supabase„ÅÆË®≠ÂÆö„ÅåInfo.plist„Å´„ÅÇ„Çä„Åæ„Åõ„Çì")
    }

    self.client = SupabaseClient(supabaseURL: url, supabaseKey: key)
  }

  var currentUser: User? {
    client.auth.currentUser
  }

  // MARK: - Ë™çË®º

  func signIn(email: String, password: String) async throws {
    try await client.auth.signIn(email: email, password: password)
    isLoggedIn = true
  }

  func signUp(email: String, password: String) async throws {
    try await client.auth.signUp(email: email, password: password)
    isLoggedIn = true
  }

  func signOut() async throws {
    try await client.auth.signOut()
    isLoggedIn = false
  }

  // MARK: - ÊúçÁîªÂÉè„Éá„Éº„Çø

  func fetchImages(for clothingId: UUID) async throws -> [ClothingImage] {
    return
      try await client
      .from("clothing_images")
      .select("*")
      .eq("clothing_id", value: clothingId.uuidString)
      .execute()
      .decoded(to: [ClothingImage].self)
  }

  func addImage(
    for clothingId: UUID, originalUrl: String, maskUrl: String? = nil, resultUrl: String? = nil
  ) async throws {
    guard let user = currentUser else {
      throw NSError(
        domain: "auth", code: 401, userInfo: [NSLocalizedDescriptionKey: "„É¶„Éº„Ç∂„Éº„ÅåÊú™„É≠„Ç∞„Ç§„É≥„Åß„Åô"])
    }

    let newImage = NewClothingImage(
      id: UUID(),
      clothing_id: clothingId,
      user_id: user.id,
      original_url: originalUrl,
      mask_url: maskUrl,
      result_url: resultUrl,
      created_at: ISO8601DateFormatter().string(from: Date())
    )

    _ =
      try await client
      .from("clothing_images")
      .insert(newImage)
      .execute()
  }

  func updateImageMaskAndResult(id: UUID, maskUrl: String?, resultUrl: String?) async throws {
    _ =
      try await client
      .from("clothing_images")
      .update([
        "mask_url": maskUrl,
        "result_url": resultUrl,
      ])
      .eq("id", value: id.uuidString)
      .execute()
  }

  func uploadImage(_ image: UIImage, for filename: String) async throws -> String {
    // „Åæ„Åö„É™„Çµ„Ç§„Ç∫„Åô„ÇãÔºàÂπÖ„ÇíÊúÄÂ§ß800px„Å´Âà∂ÈôêÔºâ
    let resizedImage = image.resized(toMaxPixel: 800)

    guard let imageData = resizedImage.jpegData(compressionQuality: 0.6) else {
      throw NSError(
        domain: "upload", code: 0, userInfo: [NSLocalizedDescriptionKey: "ÁîªÂÉè„ÅÆÂ§âÊèõ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü"])
    }

    let path = "\(filename).jpg"

    _ = try await client.storage
      .from(storageBucketName)
      .upload(path, data: imageData, options: FileOptions(contentType: "image/jpeg"))

    guard let urlString = Bundle.main.object(forInfoDictionaryKey: "SUPABASE_URL") as? String else {
      throw NSError(
        domain: "config", code: 0, userInfo: [NSLocalizedDescriptionKey: "Supabase URL„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì"])
    }

    return "\(urlString)/storage/v1/object/public/\(storageBucketName)/\(path)"
  }

  func listClothingImageURLs() async throws -> [URL] {
    guard let userId = currentUser?.id.uuidString else {
      throw NSError(
        domain: "auth", code: 401, userInfo: [NSLocalizedDescriptionKey: "„É¶„Éº„Ç∂„Éº„ÅåÊú™„É≠„Ç∞„Ç§„É≥„Åß„Åô"])
    }

    let bucket = client.storage.from(storageBucketName)
    let objects = try await bucket.list(path: userId)

    guard let baseURLString = Bundle.main.object(forInfoDictionaryKey: "SUPABASE_URL") as? String
    else {
      throw NSError(
        domain: "config", code: 0, userInfo: [NSLocalizedDescriptionKey: "Supabase URL„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì"])
    }

    let urls = objects.map { object in
      URL(
        string:
          "\(baseURLString)/storage/v1/object/public/\(storageBucketName)/\(userId)/\(object.name)")
    }

    return urls.compactMap { $0 }
  }

  // MARK: - Êúç„Éá„Éº„Çø

  func fetchClothes() async throws -> [Clothing] {
    return
      try await client
      .from("clothes")
      .select("*")
      .execute()
      .decoded(to: [Clothing].self)
  }

  func addClothing(_ clothing: Clothing) async throws {
    guard let user = currentUser else {
      throw NSError(
        domain: "auth", code: 401, userInfo: [NSLocalizedDescriptionKey: "„É¶„Éº„Ç∂„Éº„ÅåÊú™„É≠„Ç∞„Ç§„É≥„Åß„Åô"])
    }
    _ =
      try await client
      .from("clothes")
      .insert([
        "id": clothing.id.uuidString,
        "user_id": user.id.uuidString,
        "name": clothing.name,
        "category": clothing.category,
        "color": clothing.color,
        "created_at": clothing.created_at,
      ])
      .execute()
  }

  func updateClothing(_ clothing: Clothing) async throws {
    _ =
      try await client
      .from("clothes")
      .update([
        "name": clothing.name,
        "category": clothing.category,
        "color": clothing.color,
      ])
      .eq("id", value: clothing.id.uuidString)
      .execute()
  }

  func deleteClothing(_ clothing: Clothing) async throws {
    try await deleteClothingById(clothing.id)
  }

  func deleteClothingById(_ id: UUID) async throws {
    _ =
      try await client
      .from("clothes")
      .delete()
      .eq("id", value: id.uuidString)
      .execute()
  }

  // MARK: - Â§©Ê∞ó„Ç≠„É£„ÉÉ„Ç∑„É•

  func fetchWeatherCache(for city: String) async throws -> Weather {
    let today = DateFormatter.cachedDateFormatter.string(from: Date())

    let response =
      try await client
      .from("weather_cache")
      .select("*")
      .eq("city", value: city)
      .eq("date", value: today)
      .limit(1)
      .execute()

    return try response.decoded(to: Weather.self)
  }

  func insertWeatherCache(_ weather: Weather) async throws {
    _ =
      try await client
      .from("weather_cache")
      .insert(weather)
      .execute()
  }
}

extension DateFormatter {
  static let cachedDateFormatter: DateFormatter = {
    let df = DateFormatter()
    df.dateFormat = "yyyy-MM-dd"
    return df
  }()
}

extension UIImage {
  func resized(toMaxPixel maxPixel: CGFloat) -> UIImage {
    let aspectRatio = size.width / size.height
    var newSize: CGSize
    if aspectRatio > 1 {
      // Landscape
      newSize = CGSize(width: maxPixel, height: maxPixel / aspectRatio)
    } else {
      // Portrait
      newSize = CGSize(width: maxPixel * aspectRatio, height: maxPixel)
    }

    UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
    self.draw(in: CGRect(origin: .zero, size: newSize))
    let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return resizedImage ?? self
  }
}

private struct NewClothingImage: Encodable {
  let id: UUID
  let clothing_id: UUID
  let user_id: UUID
  let original_url: String
  let mask_url: String?
  let result_url: String?
  let created_at: String
}
</file>

<file path="Picklet/Services/WeatherService.swift">
//
//  WeatherService.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

// WeatherService.swift

import CoreLocation
import Foundation
import Supabase

let openWeatherApiKey = "a27cc85d4f34ac0e5e5f4fde84d5067f"

struct OpenWeatherResponse: Codable {
  struct WeatherItem: Codable {
    let description: String
    let icon: String
  }
  struct Main: Codable {
    let temp: Double
  }
  let weather: [WeatherItem]
  let main: Main
}

class WeatherManager {

  static let shared = WeatherManager()

  // „Ç≠„É£„ÉÉ„Ç∑„É•ÂèñÂæó
  func fetchCachedWeather(for city: String) async throws -> Weather {
    return try await SupabaseService.shared.fetchWeatherCache(for: city)
  }

  // Supabase„Å´‰øùÂ≠ò
  func saveWeatherToCache(_ weather: Weather) async throws {
    try await SupabaseService.shared.insertWeatherCache(weather)
  }
}
</file>

<file path="Picklet/Utilities/ImagePicker.swift">
//
//  ImagePicker.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import PhotosUI
// Utilities/ImagePicker.swift
import SwiftUI

struct ImagePicker: UIViewControllerRepresentable {
  var onImagePicked: (UIImage) -> Void

  func makeUIViewController(context: Context) -> PHPickerViewController {
    var config = PHPickerConfiguration()
    config.selectionLimit = 1
    config.filter = .images

    let picker = PHPickerViewController(configuration: config)
    picker.delegate = context.coordinator
    return picker
  }

  func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}

  func makeCoordinator() -> Coordinator {
    Coordinator(self)
  }

  class Coordinator: NSObject, PHPickerViewControllerDelegate {
    let parent: ImagePicker

    init(_ parent: ImagePicker) {
      self.parent = parent
    }

    func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
      picker.dismiss(animated: true)

      guard let provider = results.first?.itemProvider else { return }
      if provider.canLoadObject(ofClass: UIImage.self) {
        provider.loadObject(ofClass: UIImage.self) { image, error in
          if let uiImage = image as? UIImage {
            DispatchQueue.main.async {
              self.parent.onImagePicked(uiImage)
            }
          }
        }
      }
    }
  }
}
</file>

<file path="Picklet/ViewModels/ClothingViewModel.swift">
import Foundation
import SwiftUI

@MainActor
class ClothingViewModel: ObservableObject {
  @Published var clothes: [Clothing] = []
  @Published var isLoading = false
  @Published var error: String?

  @Published var imageSetsMap: [UUID: [EditableImageSet]] = [:]

  /// Êúç„Çí‰øùÂ≠òÔºàÊñ∞Ë¶è or Êõ¥Êñ∞Ôºâ
  func updateClothing(_ clothing: Clothing, imageSets: [EditableImageSet], isNew: Bool) async {
    do {
      if isNew {
        try await SupabaseService.shared.addClothing(clothing)
        print("‚úÖ Êñ∞Ë¶èÊúçÁôªÈå≤: \(clothing.name)")
      } else {
        try await SupabaseService.shared.updateClothing(clothing)
        print("‚úÖ ÊúçÊõ¥Êñ∞: \(clothing.name)")
      }

      for set in imageSets {
        if set.isNew, let original = set.original {
          let originalUrl = try await SupabaseService.shared.uploadImage(
            original, for: UUID().uuidString)
          try await SupabaseService.shared.addImage(for: clothing.id, originalUrl: originalUrl)
          print("‚úÖ ÁîªÂÉè„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ & ÁôªÈå≤ÂÆå‰∫Ü: \(originalUrl)")
        }
      }
    } catch {
      print("‚ùå Êúç„ÅÆ‰øùÂ≠ò„Ç®„É©„Éº: \(error.localizedDescription)")
      self.error = error.localizedDescription
    }
  }

  /// „Åô„Åπ„Å¶„ÅÆÊúç„Å®ÁîªÂÉè„ÇíË™≠„ÅøËæº„ÇÄÔºà‰ªä„ÅØÁîªÂÉè‰∏çË¶Å„Å™„ÇâÂâäÈô§ÂèØÔºâ
  func loadClothes() async {
    isLoading = true
    do {
      clothes = try await SupabaseService.shared.fetchClothes()
      print("‚úÖ Êúç„Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÂÆå‰∫Ü: \(clothes.count)‰ª∂")

      for clothing in clothes {
        let images = try await SupabaseService.shared.fetchImages(for: clothing.id)
        let sets = images.map { img in
          EditableImageSet(
            id: img.id,
            original: nil,
            originalUrl: img.original_url,
            mask: nil,
            maskUrl: nil,
            result: nil,
            resultUrl: nil,
            isNew: false
          )
        }
        imageSetsMap[clothing.id] = sets
      }

      print("‚úÖ ÁîªÂÉè„Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÂÆå‰∫Ü")
    } catch {
      self.error = error.localizedDescription
    }
    isLoading = false
  }

  /// Êúç„ÇíÂâäÈô§
  func deleteClothing(_ clothing: Clothing) async {
    do {
      try await SupabaseService.shared.deleteClothing(clothing)
      print("üóëÔ∏è ÂâäÈô§ÊàêÂäü: \(clothing.name)")
      await loadClothes()
    } catch {
      self.error = error.localizedDescription
    }
  }
}
</file>

<file path="Picklet/ViewModels/LibraryPickerViewModel.swift">
//
//  LibraryPickerViewModel.swift
//  MyApp
//
//  Created by al dente on 2025/04/30.
//

import Combine
// ViewModels/LibraryPickerViewModel.swift
import SwiftUI

@MainActor
final class LibraryPickerViewModel: ObservableObject {
  @Published var urls: [URL] = []

  private var cancellables = Set<AnyCancellable>()

  func fetch() {
    Task {
      do {
        self.urls = try await SupabaseService.shared.listClothingImageURLs()
      } catch {
        print("‚ùå image fetch error:", error)
      }
    }
  }
}
</file>

<file path="Picklet/ViewModels/LoginViewModel.swift">
//
//  LoginViewModel.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

// ViewModels/LoginViewModel.swift
import Foundation

@MainActor
class LoginViewModel: ObservableObject {
  @Published var email = ""
  @Published var password = ""
  @Published var errorMessage: String?
  @Published var isLoading = false
  @Published var isLoggedIn = false

  func login() async {
    do {
      try await SupabaseService.shared.signIn(email: email, password: password)
      errorMessage = nil
    } catch {
      errorMessage = "„É≠„Ç∞„Ç§„É≥„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: \(error.localizedDescription)"
    }
  }

  func signUp() async {
    do {
      try await SupabaseService.shared.signUp(email: email, password: password)
      errorMessage = nil
    } catch {
      errorMessage = "„Çµ„Ç§„É≥„Ç¢„ÉÉ„Éó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: \(error.localizedDescription)"
    }
  }
}
</file>

<file path="Picklet/Views/Capture/Camera/CameraPreviewController.swift">
//
//  CameraPreviewController.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import AVFoundation
import UIKit

class CameraPreviewController: UIViewController, AVCapturePhotoCaptureDelegate {
  var captureSession: AVCaptureSession?
  var photoOutput: AVCapturePhotoOutput?
  var previewLayer: AVCaptureVideoPreviewLayer?

  var onImageCaptured: ((UIImage) -> Void)?

  override func viewDidLoad() {
    super.viewDidLoad()
    setupCamera()
  }

  private func setupCamera() {
    captureSession = AVCaptureSession()
    captureSession?.sessionPreset = .high

    guard let backCamera = AVCaptureDevice.default(for: .video),
      let input = try? AVCaptureDeviceInput(device: backCamera),
      let captureSession = captureSession
    else { return }
    if captureSession.canAddInput(input) {
      captureSession.addInput(input)
    }
    photoOutput = AVCapturePhotoOutput()
    if let photoOutput = photoOutput, captureSession.canAddOutput(photoOutput) {
      captureSession.addOutput(photoOutput)
    }
    previewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
    previewLayer?.videoGravity = .resizeAspectFill
    previewLayer?.frame = view.bounds
    if let previewLayer = previewLayer {
      view.layer.addSublayer(previewLayer)
    }
    DispatchQueue.global(qos: .userInitiated).async {
      captureSession.startRunning()
    }
  }

  func capture() {
    let settings = AVCapturePhotoSettings()
    photoOutput?.capturePhoto(with: settings, delegate: self)
  }

  @objc private func capturePhoto() {
    let settings = AVCapturePhotoSettings()
    photoOutput?.capturePhoto(with: settings, delegate: self)
  }

  func photoOutput(
    _ output: AVCapturePhotoOutput,
    didFinishProcessingPhoto photo: AVCapturePhoto,
    error: Error?
  ) {

    guard let data = photo.fileDataRepresentation(),
      let image = UIImage(data: data),
      let layer = previewLayer
    else { return }

    // „Éó„É¨„Éì„É•„Éº„Å´ÂÜô„Å£„Å¶„ÅÑ„ÅüÁü©ÂΩ¢(0-1Ê≠£Ë¶èÂåñ) ‚Üí ÁîªÂÉèÂ∫ßÊ®ô„Å∏Â§âÊèõ
    let visible = layer.metadataOutputRectConverted(fromLayerRect: layer.bounds)
    let cg = image.cgImage!
    let crop = CGRect(
      x: visible.origin.x * CGFloat(cg.width),
      y: visible.origin.y * CGFloat(cg.height),
      width: visible.size.width * CGFloat(cg.width),
      height: visible.size.height * CGFloat(cg.height)
    ).integral

    guard let cropped = cg.cropping(to: crop) else {
      onImageCaptured?(image)  // Â§±ÊïóÊôÇ„ÅØ„Ç™„É™„Ç∏„Éä„É´
      return
    }

    onImageCaptured?(
      UIImage(
        cgImage: cropped,
        scale: image.scale,
        orientation: image.imageOrientation))
  }

  override func viewDidLayoutSubviews() {
    super.viewDidLayoutSubviews()
    previewLayer?.frame = view.bounds
  }
}
</file>

<file path="Picklet/Views/Capture/Camera/CameraPreviewView.swift">
//
//  CameraPreviewView.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import AVFoundation
import SwiftUI

struct CameraPreviewView: UIViewControllerRepresentable {
  var onImageCaptured: (UIImage) -> Void
  class Coordinator {
    var controller: CameraPreviewController?
  }

  @Binding var triggerCapture: Bool

  func makeCoordinator() -> Coordinator {
    Coordinator()
  }

  func makeUIViewController(context: Context) -> CameraPreviewController {
    let controller = CameraPreviewController()
    controller.onImageCaptured = onImageCaptured
    context.coordinator.controller = controller
    return controller
  }

  func updateUIViewController(_ uiViewController: CameraPreviewController, context: Context) {
    if triggerCapture {
      uiViewController.capture()
      DispatchQueue.main.async {
        triggerCapture = false  // reset after shot
      }
    }
  }
}
</file>

<file path="Picklet/Views/Capture/Camera/CameraSquarePreviewView.swift">
//
//  CameraSquarePreviewView.swift
//  MyApp
//
//  Created by al dente on 2025/04/30.
//

import SwiftUI

struct CameraSquarePreviewView: View {
  let onCaptured: (UIImage) -> Void
  @State private var shouldCapture = false

  var body: some View {
    GeometryReader { geo in
      let size = min(geo.size.width, geo.size.height)

      ZStack {
        CameraPreviewView(onImageCaptured: onCaptured, triggerCapture: $shouldCapture)
          .frame(width: size, height: size)
          .clipped()

        VStack {
          Spacer()
          Button(action: {
            shouldCapture = true
          }) {
            Circle()
              .fill(Color.white)
              .frame(width: 70, height: 70)
              .shadow(radius: 4)
          }
          .padding(.bottom, 40)
        }
      }
    }
  }
}
</file>

<file path="Picklet/Views/Capture/Library/LibraryPickerView.swift">
//
//  LibraryPickerView.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import PhotosUI
import SwiftUI

struct LibraryPickerView: View {
  var onImagePicked: (UIImage) -> Void
  @Environment(\.dismiss) private var dismiss
  @StateObject private var vm = LibraryPickerViewModel()
  @State private var columnsCount: Int = 10
  private let spacing: CGFloat = 4

  var body: some View {
    NavigationView {
      GeometryReader { geo in
        //                let totalSpacing = spacing * CGFloat(columnsCount + 1)
        //                let cellSize = (geo.size.width - totalSpacing) / CGFloat(columnsCount)

        VStack(spacing: spacing) {
          //                    // ÂàóÊï∞ÈÅ∏Êäû„É°„Éã„É•„Éº
          //                    HStack {
          //                        Spacer()
          //                        Menu {
          //                            Button("3Âàó") { columnsCount = 3 }
          //                            Button("4Âàó") { columnsCount = 4 }
          //                            Button("5Âàó") { columnsCount = 5 }
          //                        } label: {
          //                            Label("\(columnsCount)Âàó", systemImage: "square.grid.3x3")
          //                                .padding(.trailing, spacing)
          //                        }
          //                    }

          // „Ç∞„É™„ÉÉ„ÉâË°®Á§∫
          //                    ScrollView {
          //                        LazyVGrid(
          //                            columns: Array(repeating: .init(.fixed(cellSize), spacing: spacing), count: columnsCount),
          //                            spacing: spacing
          //                        ) {
          //                            ForEach(vm.urls, id: \.self) { url in
          //                                LibraryImageCell(url: url, cellSize: cellSize) { image in
          //                                    onImagePicked(image)
          //                                }
          //                            }
          //                        }
          //                        .padding(spacing)
          //                    }
        }
      }
      .navigationTitle("ÁîªÂÉè„ÇíÈÅ∏Êäû")
      .onAppear { vm.fetch() }
    }
  }
}

// MARK: - „Çª„É´Áî®„Çµ„Éñ„Éì„É•„Éº
struct LibraryImageCell: View {
  let url: URL
  let cellSize: CGFloat
  let onImagePicked: (UIImage) -> Void
  @Environment(\.dismiss) private var dismiss

  var body: some View {
    AsyncImage(url: url, scale: UIScreen.main.scale) { phase in
      switch phase {
      case .success(let image):
        image
          .resizable()
          .interpolation(.high)
          .scaledToFill()
          .frame(width: cellSize, height: cellSize)
          .clipped()
          .cornerRadius(6)
      case .failure:
        Color.gray.opacity(0.2)
          .frame(width: cellSize, height: cellSize)
          .overlay(Image(systemName: "xmark.octagon"))
      default:
        ProgressView()
          .frame(width: cellSize, height: cellSize)
      }
    }
    .onTapGesture {
      Task {
        if let (data, _) = try? await URLSession.shared.data(from: url),
          let uiImage = UIImage(data: data)
        {
          onImagePicked(uiImage)
          dismiss()
        }
      }
    }
  }
}
</file>

<file path="Picklet/Views/Capture/Library/PhotoLibraryPickerView.swift">
//
//  PhotoLibraryPickerView.swift
//  MyApp
//
//  Updated: keep the same item at the top when column count changes
//

import Photos
import SwiftUI

// PreferenceKey to pass each cell's vertical position up the view tree
private struct CellTopPreferenceKey: PreferenceKey {
  static var defaultValue: [String: CGFloat] = [:]
  static func reduce(value: inout [String: CGFloat], nextValue: () -> [String: CGFloat]) {
    value.merge(nextValue(), uniquingKeysWith: { $1 })
  }
}

struct PhotoLibraryPickerView: View {
  let onImagePicked: (UIImage) -> Void
  @Environment(\.dismiss) private var dismiss

  @State private var assets: [PHAsset] = []
  private let imageManager = PHCachingImageManager()

  @State private var columnsCount: Int = 4
  private let spacing: CGFloat = 4

  // id of the cell that was nearest to the top before layout change
  @State private var topVisibleId: String?

  var body: some View {
    NavigationView {
      GeometryReader { geo in
        let totalSpacing = spacing * CGFloat(columnsCount + 1)
        let cellSize = (geo.size.width - totalSpacing) / CGFloat(columnsCount)

        VStack(spacing: spacing) {
          //                    // Column selection buttons
          //                    HStack(spacing: spacing) {
          //                        ForEach([3,4,5,6,7], id: \.self) { count in
          //                            Button("\(count)Âàó") {
          //                                // remember the current top cell id before changing layout
          //                                let currentTop = topVisibleId
          //                                withAnimation {
          //                                    columnsCount = count
          //                                }
          //                                // after slight delay (layout finished) scroll to saved id
          //                                if let id = currentTop {
          //                                    DispatchQueue.main.async {
          //                                        scrollProxy?.scrollTo(id, anchor: .top)
          //                                    }
          //                                }
          //                            }
          //                            .font(.subheadline)
          //                            .padding(.vertical,6)
          //                            .padding(.horizontal,12)
          //                            .background(columnsCount==count ? Color.accentColor.opacity(0.2):Color.clear)
          //                            .cornerRadius(6)
          //                        }
          //                    }
          //                    .padding(.horizontal, spacing)
          //
          //                    Divider()

          // Grid
          ScrollViewReader { proxy in
            ScrollView {
              LazyVGrid(
                columns: Array(
                  repeating: .init(.fixed(cellSize), spacing: spacing), count: columnsCount),
                spacing: spacing
              ) {
                ForEach(assets, id: \.localIdentifier) { asset in
                  PhotoThumbnailCell(asset: asset, size: cellSize, manager: imageManager) { image in
                    onImagePicked(image)
                    dismiss()
                  }
                  .id(asset.localIdentifier)
                  .background(
                    GeometryReader { gp in
                      Color.clear.preference(
                        key: CellTopPreferenceKey.self,
                        value: [asset.localIdentifier: gp.frame(in: .named("gridSpace")).minY])
                    }
                  )
                }
              }
              .padding(spacing)
            }
            .coordinateSpace(name: "gridSpace")
            .onPreferenceChange(CellTopPreferenceKey.self) { values in
              // find the smallest non‚Äënegative Y (closest to top)
              if let (id, _) = values.filter({ $0.value >= 0 }).min(by: { $0.value < $1.value }) {
                topVisibleId = id
              }
            }
            // expose proxy to outer scope via capture list
            .onAppear { scrollProxy = proxy }
          }
        }
        .onAppear(perform: fetchAssets)
      }
      //            .navigationTitle("ÂÜôÁúü„ÇíÈÅ∏Êäû")
    }
  }

  // MARK: - Scroll proxy holder
  @State private var scrollProxy: ScrollViewProxy?

  private func fetchAssets() {
    let opts = PHFetchOptions()
    opts.sortDescriptors = [NSSortDescriptor(key: "creationDate", ascending: false)]
    let result = PHAsset.fetchAssets(with: .image, options: opts)
    var tmp: [PHAsset] = []
    result.enumerateObjects { obj, _, _ in tmp.append(obj) }
    assets = tmp
  }
}

// MARK: - Thumbnail Cell
struct PhotoThumbnailCell: View {
  let asset: PHAsset
  let size: CGFloat
  let manager: PHCachingImageManager
  let onSelect: (UIImage) -> Void

  @State private var thumbnail: UIImage?

  var body: some View {
    ZStack {
      if let thumb = thumbnail {
        Image(uiImage: thumb).resizable().scaledToFill()
      } else {
        Color.gray.opacity(0.2)
      }
    }
    .frame(width: size, height: size)
    .clipped()
    .cornerRadius(6)
    .onAppear(perform: loadThumb)
    .onTapGesture { requestFull() }
  }

  private func loadThumb() {
    let opts = PHImageRequestOptions()
    opts.deliveryMode = .highQualityFormat
    opts.resizeMode = .exact
    let target = CGSize(width: size * UIScreen.main.scale, height: size * UIScreen.main.scale)
    manager.requestImage(for: asset, targetSize: target, contentMode: .aspectFill, options: opts) {
      img, _ in thumbnail = img
    }
  }

  private func requestFull() {
    let opts = PHImageRequestOptions()
    opts.deliveryMode = .highQualityFormat
    opts.resizeMode = .exact
    opts.isNetworkAccessAllowed = true
    let target = CGSize(width: asset.pixelWidth, height: asset.pixelHeight)
    manager.requestImage(for: asset, targetSize: target, contentMode: .aspectFit, options: opts) {
      img, _ in if let img = img { onSelect(img) }
    }
  }
}
</file>

<file path="Picklet/Views/Capture/CaptureOrLibraryView.swift">
//
//  CaptureOrLibraryView.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import SwiftUI

struct CaptureOrLibraryView: View {
  var onImagePicked: (UIImage) -> Void
  var onCancel: (() -> Void)? = nil

  @Environment(\.dismiss) private var dismiss

  @State private var showCamera = true
  @State private var didPickImage = false

  var body: some View {
    VStack(spacing: 0) {
      ZStack {
        if showCamera {
          CameraSquarePreviewView { image in
            didPickImage = true
            onImagePicked(image)
            dismiss()
          }
        } else {
          PhotoLibraryPickerView { image in
            didPickImage = true
            onImagePicked(image)
            dismiss()
          }
        }
      }
      .frame(maxHeight: .infinity)

      ModeSwitchBarView(
        isCameraSelected: showCamera,
        onCamera: { showCamera = true },
        onLibrary: { showCamera = false }
      )
      .ignoresSafeArea()
      .onDisappear {
        if !didPickImage {
          onCancel?()
        }
      }
    }
  }
}
</file>

<file path="Picklet/Views/Capture/ModeSwitchBarView.swift">
//
//  ModeSwitchBarView.swift
//  MyApp
//
//  Created by al dente on 2025/04/30.
//

import SwiftUI

struct ModeSwitchBarView: View {
  let isCameraSelected: Bool
  let onCamera: () -> Void
  let onLibrary: () -> Void

  var body: some View {
    HStack {
      modeButton(icon: "camera", title: "„Ç´„É°„É©", isSelected: isCameraSelected, action: onCamera)
      modeButton(
        icon: "photo.on.rectangle", title: "„É©„Ç§„Éñ„É©„É™", isSelected: !isCameraSelected, action: onLibrary
      )
    }
    .padding()
    .background(Color(UIColor.systemBackground))
  }

  private func modeButton(
    icon: String, title: String, isSelected: Bool, action: @escaping () -> Void
  ) -> some View {
    Button(action: action) {
      VStack {
        Image(systemName: icon)
          .font(.title)
        //                Text(title)
      }
      .foregroundColor(isSelected ? .blue : .gray)
      .frame(maxWidth: .infinity)
    }
  }
}
</file>

<file path="Picklet/Views/Components/PrimaryActionButton.swift">
//
//  PrimaryActionButton.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

// Views/Components/PrimaryActionButton.swift

import SwiftUI

struct PrimaryActionButton: View {
  let title: String
  let action: () -> Void
  var backgroundColor: Color = Color.gray.opacity(0.2)  // „Éá„Éï„Ç©„É´„ÉàËñÑ„Ç∞„É¨„Éº

  var body: some View {
    Button(action: action) {
      Text(title)
        .font(.headline)
        .foregroundColor(.black)
        .frame(maxWidth: .infinity)
        .frame(height: 50)
        .background(backgroundColor)
        .cornerRadius(12)
        .padding(.horizontal, 24)
        .padding(.vertical, 8)
    }
    .background(Color(UIColor.systemBackground))  // ËÉåÊôØÈÄè„ÅëÈò≤Ê≠¢
  }
}
</file>

<file path="Picklet/Views/Dock/ClothingDockView.swift">
import Combine
import SDWebImageSwiftUI
import SwiftUI

// MARK: - Helper types

/// Wrapper so we can use UUID in sheet/navigationDestination
struct IdentifiableUUID: Identifiable, Hashable { let id: UUID }

/// Exponential‚Äëmoving‚Äëaverage cursor smoother
private struct CursorSmoother {
  private(set) var raw: CGFloat = -1000  // last tapped / dragged target X
  private(set) var ema: CGFloat = -1000  // smoothed X used for UI
  private let alpha: CGFloat = 0.25  // smoothing factor (0‚Ä•1)
  mutating func setTarget(_ x: CGFloat) { raw = x }
  mutating func step() { ema += alpha * (raw - ema) }
  var reachedTarget: Bool { abs(raw - ema) < 0.5 }
}

// MARK: - Quick pop‚Äëup view (lightweight card)

struct ClothingQuickView: View {
  let imageURL: String?
  let name: String
  let category: String
  let color: String?

  var body: some View {
    VStack(spacing: 12) {
      if let urlStr = imageURL, let url = URL(string: urlStr) {
        WebImage(url: url, options: [.queryMemoryData, .queryDiskDataSync, .refreshCached]) {
          phase in
          switch phase {
          case .success(let img): img.resizable().scaledToFit()
          case .failure(_):
            Image(systemName: "photo").resizable().scaledToFit().foregroundColor(.secondary)
          default: ProgressView()
          }
        }
        .frame(width: 150, height: 150)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
      }
      Text(name).font(.headline)
      Text(category).font(.subheadline).foregroundColor(.secondary)
      if let c = color {
        Text(c).font(.caption).padding(.horizontal, 8).padding(.vertical, 4)
          .background(Color(.secondarySystemBackground)).cornerRadius(6)
      }
    }
    .padding(24)
  }
}

// MARK: - Single card view

struct ClothingCardView: View {
  @EnvironmentObject private var vm: ClothingViewModel
  @Binding var clothing: Clothing

  let imageURL: String?
  let angle: Angle
  let scale: CGFloat
  let xOffset: CGFloat
  let zIndex: Double
  let onPeek: () -> Void
  let onPopAttempt: () -> Void

  var body: some View {
    ClothingItemView(clothing: clothing, imageUrl: imageURL)
      .environmentObject(vm)
      .frame(width: 120)
      .rotation3DEffect(angle, axis: (0, -1, 0), perspective: 0.7)
      .scaleEffect(scale)
      .offset(x: xOffset)
      .zIndex(zIndex)
      .gesture(
        LongPressGesture(minimumDuration: 0.25, maximumDistance: 20)
          .onEnded { _ in
            UIImpactFeedbackGenerator(style: .heavy).impactOccurred()
            onPeek()
          }
      )
  }
}

// MARK: - Dock View

struct ClothingDockView: View {
  @EnvironmentObject private var vm: ClothingViewModel

  // configuration
  private let maxCards = 20
  private let cardWidth: CGFloat = 120
  private let influence: CGFloat = 160
  private let sideMargin: CGFloat = 0.2

  // cursor smoothing
  @State private var smoother = CursorSmoother()
  @State private var smoothingOn = false

  // Peek & Pop state
  @State private var previewId: IdentifiableUUID? = nil
  @State private var commitId: UUID? = nil

  // timer
  private let tick = Timer.publish(every: 1 / 60, on: .main, in: .common).autoconnect()

  var body: some View {
    GeometryReader { geo in
      ZStack {
        let items = Array(vm.clothes.prefix(maxCards))
        let centreX = geo.size.width / 2

        ForEach(Array(zip(vm.clothes.indices, $vm.clothes)), id: \.1.id) { idx, $clothing in
          let baseX = baseOffsetX(idx: idx, total: items.count, width: geo.size.width)
          let dx = smoother.ema - baseX
          let t = clamp(1 - abs(dx) / influence, 0, 1)
          let angle = Angle(radians: -Double(atan(dx / (cardWidth / 2))))
          let scale = 1 / (2 - t)

          ClothingCardView(
            clothing: $clothing,
            imageURL: vm.imageSetsMap[clothing.id]?.first?.originalUrl,
            angle: angle,
            scale: scale,
            xOffset: baseX - centreX,
            zIndex: Double(t),
            onPeek: { previewId = IdentifiableUUID(id: clothing.id) },
            onPopAttempt: {}
            //                        onPopAttempt: { commitIfFront(id: clothing.id, dx: dx) }
          )
        }
      }
      .frame(maxWidth: .infinity, maxHeight: .infinity)
      // drag
      .contentShape(Rectangle())
      .gesture(
        DragGesture(minimumDistance: 0)
          .onChanged { v in setCursor(to: v.location.x) }
      )
      // smoother tick
      .onReceive(tick) { _ in stepSmoother() }
      // overlay (peek)
      .overlay { overlayQuickView() }
      // pop navigation
      .navigationDestination(item: $commitId) { id in
        if let binding = bindingFor(id: id) {
          ClothingDetailView(clothing: binding, clothingId: id)
            .environmentObject(vm)
        }
      }
      .task {  // initial centre
        if smoother.raw < 0 { setCursor(to: geo.size.width / 2) }
      }
    }
  }

  // MARK: ‚Äì Cursor helpers
  private func setCursor(to x: CGFloat) {
    smoother.setTarget(x)
    smoothingOn = true
  }
  private func stepSmoother() {
    guard smoothingOn else { return }
    smoother.step()
    if smoother.reachedTarget { smoothingOn = false }
  }

  // MARK: ‚Äì Peek / Pop helpers
  private func overlayQuickView() -> some View {
    Group {
      if let wrap = previewId,
        let cloth = vm.clothes.first(where: { $0.id == wrap.id })
      {
        ZStack {
          Color.black.opacity(0.5).ignoresSafeArea()
            .onTapGesture { previewId = nil }
          ClothingQuickView(
            imageURL: vm.imageSetsMap[cloth.id]?.first?.originalUrl,
            name: cloth.name,
            category: cloth.category,
            color: cloth.color
          )
          .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 20))
          .shadow(radius: 10)
          .transition(.scale.combined(with: .opacity))
          .onTapGesture {
            commitId = cloth.id
            previewId = nil
          }
        }
        .zIndex(20)
        .animation(.spring(), value: previewId)
      }
    }
  }

  // MARK: ‚Äì Utilities
  private func baseOffsetX(idx: Int, total: Int, width: CGFloat) -> CGFloat {
    let usable = width * (1 - 2 * sideMargin)
    return width * sideMargin + usable * CGFloat(idx) / CGFloat(max(total - 1, 1))
  }

  private func bindingFor(id: UUID) -> Binding<Clothing>? {
    guard let i = vm.clothes.firstIndex(where: { $0.id == id }) else { return nil }
    return $vm.clothes[i]
  }

  private func clamp<T: Comparable>(_ v: T, _ lo: T, _ hi: T) -> T { min(max(v, lo), hi) }
}
</file>

<file path="Picklet/Views/Edit/Image/ImageEditView.swift">
//
//  ImageEditView.swift
//  MyApp
//
//  Created by al dente on 2025/04/29.
//

// ImageEditView.swift
import SwiftUI

struct CropingMessageView: View {
  var body: some View {
    Color.black.opacity(0.4)  // üî≤ ÂÖ®‰Ωì„ÇíÊöó„Åè„Åô„Çã
      .ignoresSafeArea()

    VStack {
      ProgressView("AI„ÅåÁîªÂÉè„ÇíÂàá„ÇäÊäú„ÅÑ„Å¶„ÅÑ„Åæ„Åô")
        .padding()
        .background(.ultraThinMaterial)
        .cornerRadius(12)
        .foregroundColor(.primary)
    }
    .padding()
    .transition(.opacity)
  }
}

struct ImageEditView: View {
  @Binding var imageSet: EditableImageSet?

  @State private var maskedImage: UIImage?
  @State private var isCropping = true

  var body: some View {
    ZStack {
      VStack {
        if let set = imageSet {
          if isCropping {
            ImageView(image: set.original, urlStr: set.originalUrl)
          } else {
            ImageView(image: set.mask, urlStr: set.maskUrl)
          }
        } else {
          Text("ÁîªÂÉè„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
        }
      }
      .padding()
      .task {
        await processImageSet()
      }
      if isCropping {
        CropingMessageView()
      }
    }
  }

  private func processImageSet() async {
    if let output = await CoreMLService.shared.processImageSet(imageSet: imageSet) {
      imageSet = output
      isCropping = false
    }
  }
}
</file>

<file path="Picklet/Views/Edit/Image/ImageView.swift">
//
//  ImageView.swift
//  MyApp
//
//  Created by al dente on 2025/05/01.
//

import SDWebImageSwiftUI
import SwiftUI

struct DecoratedImage: View {
  let image: Image
  let size: CGFloat

  var body: some View {
    image
      .resizable()
      .aspectRatio(1, contentMode: .fill)
      .frame(width: size, height: size)
      .clipped()
      .cornerRadius(12)
      .shadow(radius: 4)
  }
}

struct ImageView: View {
  let image: UIImage?
  let urlStr: String?

  var body: some View {
    if let image = image {
      DecoratedImage(image: Image(uiImage: image), size: 300)
    } else if let urlStr = urlStr, let url = URL(string: urlStr) {
      WebImage(url: url, options: [.queryMemoryData, .queryDiskDataSync, .refreshCached]) { phase in
        switch phase {
        case .empty:
          ProgressView()
        case .success(let image):
          DecoratedImage(image: image, size: 300)
        case .failure:
          Text("ÁîªÂÉèË™≠„ÅøËæº„ÅøÂ§±Êïó")
        @unknown default:
          EmptyView()
        }
      }
    } else {
      Text("ÁîªÂÉè„Å™„Åó")
    }
  }
}
</file>

<file path="Picklet/Views/Edit/ClothingEditView.swift">
import SDWebImageSwiftUI
import SwiftUI

struct ClothingEditView: View {
  @EnvironmentObject var viewModel: ClothingViewModel
  @Environment(\.dismiss) var dismiss
  @Binding var clothing: Clothing

  let openPhotoPickerOnAppear: Bool
  let canDelete: Bool
  let isNew: Bool

  @State private var showPhotoPicker = false
  @State private var showImageEditView = false
  @State private var showDeleteConfirm = false

  @State private var imageSets: [EditableImageSet] = []
  @State private var selectedImageSet: EditableImageSet? = nil

  var body: some View {
    VStack {
      Form {
        ScrollView(.horizontal, showsIndicators: false) {
          HStack {
            ForEach(imageSets) { imageSet in
              imageButton(for: imageSet)
            }
            Button(action: {
              showPhotoPicker = true
            }) {
              VStack {
                Image(systemName: "plus")
                  .font(.largeTitle)
                  .frame(width: 150, height: 150)
                  .background(Color.gray.opacity(0.2))
                  .cornerRadius(8)
              }
            }
          }
          .padding(.vertical)
        }
        Section(header: Text("Êúç„ÅÆÊÉÖÂ†±")) {
          TextField("ÂêçÂâç", text: $clothing.name)
          TextField("„Ç´„ÉÜ„Ç¥„É™", text: $clothing.category)
          TextField("Ëâ≤", text: $clothing.color)
        }

        if canDelete {
          Section {
            Button(role: .destructive) {
              showDeleteConfirm = true
            } label: {
              Text("„Åì„ÅÆÊúç„ÇíÂâäÈô§„Åô„Çã")
                .foregroundColor(.red)
                .frame(maxWidth: .infinity, alignment: .center)
            }
          }
        }
      }

      PrimaryActionButton(title: "Â§âÊõ¥„Çí‰øùÂ≠ò") {
        Task {
          await saveChanges()
          dismiss()
        }
      }
      .padding()
    }
    .navigationTitle("Êúç„ÇíÁ∑®ÈõÜ")
    .sheet(isPresented: $showPhotoPicker) {
      CaptureOrLibraryView { selectedImage in
        let newSet = EditableImageSet(
          id: UUID(),
          original: selectedImage.normalized(),
          originalUrl: nil,
          mask: nil,
          maskUrl: nil,
          result: nil,
          resultUrl: nil,
          isNew: true
        )
        imageSets.append(newSet)
      }
    }
    .confirmationDialog("Êú¨ÂΩì„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü", isPresented: $showDeleteConfirm) {
      Button("ÂâäÈô§„Åô„Çã", role: .destructive) {
        Task {
          await viewModel.deleteClothing(clothing)
          dismiss()
        }
      }
      Button("„Ç≠„É£„É≥„Çª„É´", role: .cancel) {}
    }
    .task {
      await loadImages()
    }
    .onAppear {
      if openPhotoPickerOnAppear {
        showPhotoPicker = true
      }
    }
    .sheet(isPresented: $showImageEditView) {
      ImageEditView(imageSet: $selectedImageSet)
    }
  }

  private func loadImages() async {
    do {
      let fetchedImages = try await SupabaseService.shared.fetchImages(for: clothing.id)
      imageSets = fetchedImages.map { clothingImage in
        EditableImageSet(
          id: clothingImage.id,
          original: nil,
          originalUrl: clothingImage.original_url,
          mask: nil,
          maskUrl: nil,
          result: nil,
          resultUrl: nil,
          isNew: false
        )
      }
    } catch {
      print("‚ùå ÁîªÂÉèÂèñÂæó„Ç®„É©„Éº: \(error.localizedDescription)")
    }
  }

  private func saveChanges() async {
    do {
      if isNew {
        try await SupabaseService.shared.addClothing(clothing)
      } else {
        try await SupabaseService.shared.updateClothing(clothing)
      }

      for set in imageSets {
        if set.isNew, let original = set.original {
          let originalUrl = try await SupabaseService.shared.uploadImage(
            original, for: UUID().uuidString)
          try await SupabaseService.shared.addImage(for: clothing.id, originalUrl: originalUrl)
          print("‚úÖ ÁîªÂÉè‰øùÂ≠òÂÆå‰∫Ü: \(originalUrl)")
        }
      }
    } catch {
      print("‚ùå ‰øùÂ≠ò„Ç®„É©„Éº: \(error.localizedDescription)")
    }
  }

  private func imageButton(for imageSet: EditableImageSet) -> some View {
    Button {
      selectedImageSet = imageSet
      showImageEditView = true
    } label: {
      Group {
        if let original = imageSet.original {
          Image(uiImage: original)
            .resizable()
        } else if let urlString = imageSet.originalUrl, let url = URL(string: urlString) {
          WebImage(url: url)
            .resizable()
            .indicator(.activity)
        } else {
          Color.gray
        }
      }
      .scaledToFill()
      .frame(width: 150, height: 150)
      .clipped()
      .cornerRadius(8)
    }
  }
}
</file>

<file path="Picklet/Views/ClothingCropEditView.swift">
//
//  ClothingCropEditView.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import SwiftUI

struct ClothingCropEditView: View {
  let originalImage: UIImage
  let onComplete: (UIImage) -> Void

  @State private var userMaskImage = UIImage()
  @State private var currentPenColor = UIColor.white

  @Environment(\.dismiss) private var dismiss

  @State private var maskedImage: UIImage?
  @State private var isLoading = true

  @StateObject private var canvasCoordinator = MaskEditCanvasView.Coordinator()

  var body: some View {
    VStack {
      if isLoading {
        ProgressView("AI„ÅåÊúç„ÇíÂàá„ÇäÊäú„ÅÑ„Å¶„ÅÑ„Åæ„Åô‚Ä¶")
          .padding()
      } else if let result = maskedImage {
        ZStack {
          Image(uiImage: result)
            .resizable()
            .scaledToFit()
            .padding()

          MaskEditCanvasView(drawingImage: $userMaskImage, penColor: currentPenColor, penWidth: 20)
            .frame(width: 300, height: 400)
            .background(Color.clear)
            .environmentObject(canvasCoordinator)
        }

        Button("ÁôªÈå≤„Åô„Çã") {
          let exportedMask = canvasCoordinator.exportDrawingImage()
          onComplete(exportedMask)
          dismiss()
        }
        .padding()
      } else {
        Text("Âàá„ÇäÊäú„Åç„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")
        Button("Êàª„Çã") {
          dismiss()
        }
        .padding()
      }
    }
    .navigationTitle("ÁîªÂÉèÁ∑®ÈõÜ")
    .navigationBarTitleDisplayMode(.inline)
    .task {
      await processImage()
    }
  }

  private func processImage() async {
    if let output = await CoreMLService.shared.processImage(image: originalImage) {
      self.maskedImage = output
    }
    self.isLoading = false
  }
}
</file>

<file path="Picklet/Views/ClothingCropPreviewView.swift">
////
////  ClothingCropPreviewView.swift
////  MyApp
////
////  Created by al dente on 2025/04/26.
////
//
//import SwiftUI
//
//struct ClothingCropPreviewView: View {
//    @Environment(\.dismiss) private var dismiss
//    let originalImage: UIImage
//    var onConfirm: (UIImage) -> Void
//    var onRetry: () -> Void
//
//    @State private var maskedImage: UIImage?
//    @State private var maskVisualizationImage: UIImage?
//    @State private var progress: Double = 0.0
//    @State private var isAnimating = false
//
//    @State private var isLoading = true
//    @State private var timer: Timer?
//
//    var body: some View {
//        VStack {
//            if isLoading {
//                VStack(spacing: 16) {
//                    ProgressView("AI„ÅåÊúç„ÇíÂàá„ÇäÊäú„ÅÑ„Å¶„ÅÑ„Åæ„Åô‚Ä¶")
//                    Text("„Åä‰Ωø„ÅÑ„ÅÆiPhone‰∏ä„ÅßAI„ÅåÂãï‰Ωú‰∏≠„Åß„Åô")
//                        .font(.caption)
//                        .foregroundColor(.gray)
//                }
//                .padding()
//            } else {
//                if let masked = maskedImage, let maskVisual = maskVisualizationImage {
//                    ZStack {
//                        Image(uiImage: masked)
//                            .resizable()
//                            .scaledToFit()
//                            .opacity(1.0 - progress)
//
//                        Image(uiImage: maskVisual)
//                            .resizable()
//                            .scaledToFit()
//                            .opacity(progress)
//                    }
//                    .animation(.easeInOut(duration: 1.5), value: progress)
//                    .padding()
//
//                    HStack {
//                        Button("„ÇÑ„ÇäÁõ¥„Åô") {
//                            stopAnimation()
//                            onRetry()
//                        }
//                        .padding()
//
//                        Button("„Åì„ÅÆÁîªÂÉè„ÅßÁôªÈå≤") {
//                            stopAnimation()
//                            onConfirm(masked)
//                            dismiss()
//                        }
//                        .padding()
//                    }
//                } else {
//                    Text("Âàá„ÇäÊäú„Åç„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")
//                    Button("„ÇÑ„ÇäÁõ¥„Åô") {
//                        stopAnimation()
//                        onRetry()
//                    }
//                }
//            }
//        }
//        .onAppear {
//            print("üõ† CropPreviewView appearedÔºÅoriginalImage„ÅÇ„Çä")
//
//            Task {
//                print("üõ† CoreML processImageÈñãÂßã")
//
//                let inputImage = originalImage.fixedOrientation()
//
//                if let final = await CoreMLService.shared.processImage(image: inputImage),
//                   let maskOnly = CoreMLService.shared.predictMask(for: inputImage) {
//
//                    self.maskedImage = final
//                    self.maskVisualizationImage = ImageProcessor.visualizeMaskOnOriginal(original: inputImage, mask: maskOnly)
//
//                    print("üõ† maskedImage„Å®maskVisualizationImage„Çª„ÉÉ„ÉàÂÆå‰∫ÜÔºÅ")
//
//                    startAnimation()
//                } else {
//                    print("‚ùå maskedImage‰ΩúÊàêÂ§±Êïó")
//                }
//
//                self.isLoading = false
//            }
//        }
//        .onDisappear {
//            stopAnimation()
//        }
//    }
//
//    // ‚≠êÔ∏è „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Çπ„Çø„Éº„Éà
//    private func startAnimation() {
//        timer = Timer.scheduledTimer(withTimeInterval: 1.5, repeats: true) { _ in
//            withAnimation(.easeInOut(duration: 1.5)) {
//                self.progress = (self.progress == 1.0) ? 0.0 : 1.0
//            }
//        }
//    }
//
//    // ‚≠êÔ∏è „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Çπ„Éà„ÉÉ„Éó
//    private func stopAnimation() {
//        timer?.invalidate()
//        timer = nil
//    }
//}
</file>

<file path="Picklet/Views/ClothingDetailView.swift">
import SDWebImageSwiftUI
import SwiftUI

struct ClothingDetailView: View {
  @EnvironmentObject var viewModel: ClothingViewModel
  @Environment(\.dismiss) private var dismiss

  @Binding var clothing: Clothing
  let clothingId: UUID

  @State private var showEdit = false
  @State private var images: [ClothingImage] = []

  var body: some View {
    VStack {
      ScrollView(.horizontal, showsIndicators: false) {
        HStack {
          ForEach(images) { image in
            if let url = URL(string: image.original_url) {
              WebImage(url: url, options: [.queryMemoryData, .queryDiskDataSync, .refreshCached])
                .resizable()
                .indicator(.activity)
                .transition(.fade(duration: 0.5))
                .scaledToFill()
                .frame(width: 150, height: 150)
                .clipped()
                .cornerRadius(8)
            } else {
              Rectangle()
                .fill(Color.gray.opacity(0.2))
                .frame(width: 150, height: 150)
                .cornerRadius(8)
            }
          }
        }
        .padding()
      }

      Text(clothing.name)
        .font(.title)

      Spacer()
    }
    .navigationTitle("Êúç„ÅÆË©≥Á¥∞")
    .safeAreaInset(edge: .bottom) {
      PrimaryActionButton(title: "Á∑®ÈõÜ„Åô„Çã") {
        showEdit = true
      }
    }
    .sheet(isPresented: $showEdit) {
      ClothingEditView(
        clothing: $clothing,
        openPhotoPickerOnAppear: false,
        canDelete: true,
        isNew: false
      )
      .environmentObject(viewModel)
    }
    .onChange(of: viewModel.clothes) { oldClothes, newClothes in
      if !newClothes.contains(where: { $0.id == clothingId }) {
        dismiss()
      }
    }
    .task {
      await loadImages()
    }
  }

  private func loadImages() async {
    do {
      images = try await SupabaseService.shared.fetchImages(for: clothing.id)
    } catch {
      print("‚ùå ÁîªÂÉèÂèñÂæó„Ç®„É©„Éº: \(error.localizedDescription)")
    }
  }
}
</file>

<file path="Picklet/Views/ClothingItemView.swift">
import SDWebImageSwiftUI
import SwiftUI

struct ClothingItemView: View {
  let clothing: Clothing
  let imageUrl: String?

  var body: some View {
    VStack {
      if let urlString = imageUrl, let url = URL(string: urlString) {
        WebImage(url: url, options: [.queryMemoryData, .queryDiskDataSync, .refreshCached])
          .resizable()
          .indicator(.activity)
          .transition(.fade(duration: 0.5))
          .scaledToFill()
          .frame(width: 100, height: 100)
          .clipped()
          .cornerRadius(8)
      } else {
        placeholderView
      }
    }
    .frame(width: 100)
    .padding()
    .background(Color(.secondarySystemBackground))
    .cornerRadius(12)
    .shadow(radius: 2)
  }

  private var placeholderView: some View {
    Rectangle()
      .fill(Color.gray.opacity(0.2))
      .frame(width: 100, height: 100)
      .cornerRadius(8)
  }
}
</file>

<file path="Picklet/Views/ClothingListView.swift">
import SwiftUI

// PreferenceKey to capture each item's vertical offset in the scroll view
private struct TopItemPreferenceKey: PreferenceKey {
  static var defaultValue: [UUID: CGFloat] = [:]
  static func reduce(value: inout [UUID: CGFloat], nextValue: () -> [UUID: CGFloat]) {
    value.merge(nextValue(), uniquingKeysWith: { $1 })
  }
}

struct ClothingListView: View {
  @StateObject private var viewModel = ClothingViewModel()

  // grid columns can be changed by the user (2‚Äì4) ‚Äì default 2
  @State private var columnCount: Int = 2

  // id of the item that is currently top‚Äëmost (captured via PreferenceKey)
  @State private var topVisibleId: UUID?

  // scroll proxy saved once to reuse when columnCount changes
  @State private var scrollProxy: ScrollViewProxy?

  @State private var navigateToEdit = false
  @State private var editingClothing: Clothing?
  @State private var isNewClothing = false

  // spacing between cells
  private let spacing: CGFloat = 16

  @State private var useDockView = true

  var body: some View {
    NavigationStack {
      ClothingDockView().environmentObject(viewModel)
        //            VStack(spacing: 0) {
        //                // column selector
        //                HStack(spacing: 12) {
        //                    ForEach(2...4, id: \ .self) { n in
        //                        Button("\(n)") {
        //                            // remember current top before changing layout
        //                            let currentTop = topVisibleId
        //                            withAnimation { columnCount = n }
        //                            // after layout change, scroll back to the same item
        //                            if let id = currentTop {
        //                                DispatchQueue.main.async {
        //                                    scrollProxy?.scrollTo(id, anchor: .top)
        //                                }
        //                            }
        //                        }
        //                        .padding(6)
        //                        .background(columnCount == n ? Color.accentColor.opacity(0.2) : Color.clear)
        //                        .cornerRadius(6)
        //                    }
        //                }
        //                .font(.subheadline)
        //                .padding([.horizontal,.top])
        //
        //                ScrollViewReader { proxy in
        //                    ScrollView {
        //                        LazyVGrid(columns: Array(repeating: .init(.flexible(), spacing: spacing), count: columnCount), spacing: spacing) {
        //                            ForEach($viewModel.clothes, id: \ .id) { $clothing in
        //                                NavigationLink(destination: ClothingDetailView(clothing: $clothing, clothingId: clothing.id).environmentObject(viewModel)) {
        //                                    ClothingItemView(clothing: clothing, imageUrl: viewModel.imageSetsMap[clothing.id]?.first?.originalUrl)
        //                                        .environmentObject(viewModel)
        //                                }
        //                                .id(clothing.id) // enable scrollTo
        //                                .background(
        //                                    GeometryReader { geo in
        //                                        Color.clear.preference(key: TopItemPreferenceKey.self, value: [clothing.id: geo.frame(in: .named("gridSpace")).minY])
        //                                    }
        //                                )
        //                            }
        //                        }
        //                        .padding(spacing)
        //                    }
        //                    .coordinateSpace(name: "gridSpace")
        //                    .onPreferenceChange(TopItemPreferenceKey.self) { values in
        //                        if let (id, _) = values.filter({ $0.value >= 0 }).min(by: { $0.value < $1.value }) {
        //                            topVisibleId = id
        //                        }
        //                    }
        //                    .onAppear { scrollProxy = proxy }
        //                }
        //            }
        .navigationTitle("My Clothes")
        .safeAreaInset(edge: .bottom) {
          PrimaryActionButton(title: "ÂÜôÁúü„Åã„ÇâÊúç„ÇíËøΩÂä†") {
            if let user = SupabaseService.shared.currentUser {
              let newClothing = Clothing(
                id: UUID(), user_id: user.id, name: "", category: "", color: "",
                created_at: ISO8601DateFormatter().string(from: Date()), updated_at: "")
              self.editingClothing = newClothing
              self.isNewClothing = true
              self.navigateToEdit = true
            }
          }
        }
        .navigationDestination(isPresented: $navigateToEdit) {
          if let editingClothing = editingClothing {
            ClothingEditView(
              clothing: Binding(get: { editingClothing }, set: { self.editingClothing = $0 }),
              openPhotoPickerOnAppear: true, canDelete: false, isNew: true
            )
            .environmentObject(viewModel)
          }
        }
        .task { await viewModel.loadClothes() }
    }
  }
}
</file>

<file path="Picklet/Views/EditableImageSet.swift">
//
//  EditableImageSet.swift
//  MyApp
//
//  Created by al dente on 2025/04/29.
//

import SwiftUI

struct EditableImageSet: Identifiable {
  let id: UUID
  var original: UIImage?
  var originalUrl: String?
  var mask: UIImage?
  var maskUrl: String?
  var result: UIImage?
  var resultUrl: String?
  var isNew: Bool
}

extension EditableImageSet {
  init(original: UIImage) {
    self.id = UUID()
    self.original = original
    self.originalUrl = nil
    self.mask = nil
    self.maskUrl = nil
    self.result = nil
    self.resultUrl = nil
    self.isNew = true
  }
}
</file>

<file path="Picklet/Views/LocationTestView.swift">
//
//  LocationTestView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import SwiftUI

struct LocationTestView: View {
  @StateObject private var locationManager = LocationManager()

  var body: some View {
    VStack {
      if let placemark = locationManager.placemark {
        Text("ÈÉΩÈÅìÂ∫úÁúå: \(placemark.administrativeArea ?? "‰∏çÊòé")")
        Text("Â∏ÇÂå∫Áî∫Êùë: \(placemark.locality ?? "‰∏çÊòé")")
      } else if let error = locationManager.locationError {
        Text("„Ç®„É©„Éº: \(error.localizedDescription)")
      } else {
        Text("‰ΩçÁΩÆÊÉÖÂ†±„ÇíÂèñÂæó‰∏≠...")
      }
    }
    .padding()
  }
}
</file>

<file path="Picklet/Views/LoginView.swift">
//
//  LoginView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

// Views/LoginView.swift
import SwiftUI

struct LoginView: View {
  @StateObject private var viewModel = LoginViewModel()

  var body: some View {
    VStack(spacing: 16) {
      Text("„É≠„Ç∞„Ç§„É≥")
        .font(.largeTitle)
        .bold()

      TextField("„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ", text: $viewModel.email)
        .autocapitalization(.none)
        .textFieldStyle(RoundedBorderTextFieldStyle())
        .keyboardType(.emailAddress)

      SecureField("„Éë„Çπ„ÉØ„Éº„Éâ", text: $viewModel.password)
        .textFieldStyle(RoundedBorderTextFieldStyle())

      if let error = viewModel.errorMessage {
        Text(error)
          .foregroundColor(.red)
          .font(.caption)
      }

      if viewModel.isLoading {
        ProgressView()
      }

      Button("„É≠„Ç∞„Ç§„É≥") {
        Task {
          await viewModel.login()
        }
      }

      Button("Êñ∞Ë¶èÁôªÈå≤") {
        Task { await viewModel.signUp() }
      }
    }
    .padding()
  }
}
</file>

<file path="Picklet/Views/MainTabView.swift">
//
//  MainTabView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import SwiftUI

struct MainTabView: View {
  var body: some View {
    TabView {
      ClothingListView()
        .tabItem {
          //                    Label("„ÇØ„É≠„Éº„Çº„ÉÉ„Éà", systemImage: "tshirt")
          Image(systemName: "tshirt")

        }

      //            WeatherLoaderView()
      //                .tabItem {
      //                    Label("‰ªäÊó•„ÅÆ„Ç≥„Éº„Éá", systemImage: "sun.max")
      //                }

      SettingsView()
        .tabItem {
          //                    Label("Ë®≠ÂÆö", systemImage: "gear")
          Image(systemName: "gear")
        }
    }
  }
}
</file>

<file path="Picklet/Views/MaskEditCanvasView.swift">
//
//  MaskEditCanvasView.swift
//  MyApp
//
//  Created by al dente on 2025/04/28.
//

import SwiftUI

struct MaskEditCanvasView: UIViewRepresentable {
  @Binding var drawingImage: UIImage
  var penColor: UIColor
  var penWidth: CGFloat = 20.0

  func makeCoordinator() -> Coordinator {
    Coordinator()
  }

  func makeUIView(context: Context) -> DrawingCanvas {
    let canvas = DrawingCanvas()
    context.coordinator.canvas = canvas
    canvas.isUserInteractionEnabled = true
    return canvas
  }

  func updateUIView(_ uiView: DrawingCanvas, context: Context) {
    uiView.penColor = penColor
    uiView.penWidth = penWidth
  }

  class Coordinator: ObservableObject {
    var canvas: DrawingCanvas?

    func exportDrawingImage() -> UIImage {
      return canvas?.exportDrawingImage() ?? UIImage()
    }
  }

  class DrawingCanvas: UIView {
    private var lines: [Line] = []
    var penColor: UIColor = .white
    var penWidth: CGFloat = 20.0
    private var lastPoint: CGPoint?

    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
      if let point = touches.first?.location(in: self) {
        lastPoint = point
      }
    }

    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
      guard let point = touches.first?.location(in: self), let last = lastPoint else { return }
      lines.append(Line(from: last, to: point, color: penColor, width: penWidth))
      lastPoint = point
      setNeedsDisplay()
    }

    override func draw(_ rect: CGRect) {
      guard let context = UIGraphicsGetCurrentContext() else { return }
      for line in lines {
        context.setStrokeColor(line.color.cgColor)
        context.setLineWidth(line.width)
        context.setLineCap(.round)
        context.move(to: line.from)
        context.addLine(to: line.to)
        context.strokePath()
      }
    }

    func exportDrawingImage() -> UIImage {
      UIGraphicsBeginImageContextWithOptions(bounds.size, false, 0)
      drawHierarchy(in: bounds, afterScreenUpdates: true)
      let image = UIGraphicsGetImageFromCurrentImageContext()
      UIGraphicsEndImageContext()
      return image ?? UIImage()
    }
  }

  struct Line {
    let from: CGPoint
    let to: CGPoint
    let color: UIColor
    let width: CGFloat
  }
}
</file>

<file path="Picklet/Views/SettingsView.swift">
//
//  SettingsView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import SwiftUI

struct SettingsView: View {
  @Environment(\.dismiss) var dismiss
  @AppStorage("autoCropEnabled") private var autoCropEnabled: Bool = true

  var body: some View {
    NavigationView {
      Form {
        Section(header: Text("Âàá„ÇäÊäú„ÅçË®≠ÂÆö")) {
          Toggle("Ëá™Âãï„ÅßÂàá„ÇäÊäú„Åè", isOn: $autoCropEnabled)
        }

        Section {
          Button("„É≠„Ç∞„Ç¢„Ç¶„Éà", role: .destructive) {
            Task {
              try? await SupabaseService.shared.signOut()
              dismiss()
            }
          }
        }
      }
      .navigationTitle("Ë®≠ÂÆö")
    }
  }
}
</file>

<file path="Picklet/Views/WeatherLoaderView.swift">
//
//  WeatherLoaderView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import SwiftUI

struct WeatherLoaderView: View {
  @StateObject private var locationManager = LocationManager()
  @State private var weather: Weather?
  @State private var isLoading = true
  @State private var errorMessage: String?

  var body: some View {
    Group {
      if isLoading {
        ProgressView("Â§©Ê∞óÊÉÖÂ†±„ÇíÂèñÂæó‰∏≠...")
      } else if let weather = weather {
        WeatherView(weather: weather)
      } else if let errorMessage = errorMessage {
        Text(errorMessage)
          .foregroundColor(.red)
          .padding()
      }
    }
    .onChange(of: locationManager.placemark) {
      guard weather == nil && errorMessage == nil else { return }
      Task {
        await loadWeather()
      }
    }

  }

  private func loadWeather() async {
    print("üåÄ loadWeather called")
    guard let placemark = locationManager.placemark else {
      errorMessage = "‰ΩçÁΩÆÊÉÖÂ†±„ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü"
      isLoading = false
      return
    }

    // Áúå„ÇÑÂ∏Ç„ÅÆË°®Á§∫Á¢∫Ë™ç
    let prefecture = placemark.administrativeArea ?? "‰∏çÊòé"
    let city = placemark.locality ?? placemark.subAdministrativeArea ?? "‰∏çÊòé"

    print("üóæ ÁèæÂú®Âú∞: \(prefecture) / \(city)")

    if city == "‰∏çÊòé" {
      errorMessage = "‰ΩçÁΩÆÊÉÖÂ†±„Åã„ÇâÂ∏ÇÂå∫Áî∫Êùë„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü"
      isLoading = false
      return
    }

    do {
      let fetchedWeather = try await WeatherManager.shared.fetchCachedWeather(for: city)
      self.weather = fetchedWeather
    } catch {
      self.errorMessage = "Â§©Ê∞óÊÉÖÂ†±„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: \(error.localizedDescription)"
      print("‚ùå Â§©Ê∞óÂèñÂæóÂ§±Êïó: \(error)")
    }

    isLoading = false
  }

}
</file>

<file path="Picklet/Views/WeatherView.swift">
//
//  WeatherView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import SwiftUI

struct WeatherView: View {
  let weather: Weather

  var body: some View {
    VStack(spacing: 8) {
      if let url = URL(string: "https://openweathermap.org/img/wn/\(weather.icon)@2x.png") {
        AsyncImage(url: url) { image in
          image
            .resizable()
            .scaledToFit()
            .frame(width: 100, height: 100)
        } placeholder: {
          ProgressView()
        }
      }
      Text(weather.condition)
        .font(.headline)
      Text("\(weather.temperature, specifier: "%.1f")‚ÑÉ")
        .font(.title)
        .bold()
    }
    .padding()
  }
}
</file>

<file path="Picklet/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDocumentTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeName</key>
			<string></string>
			<key>LSHandlerRank</key>
			<string>Default</string>
		</dict>
	</array>
	<key>CFBundleURLTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLName</key>
			<string></string>
			<key>CFBundleURLSchemes</key>
			<array/>
		</dict>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLName</key>
			<string></string>
		</dict>
	</array>
	<key>SUPABASE_KEY</key>
	<string>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZsbXdsdmthaXpncmNxenlvbmZ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU1MDM0NzAsImV4cCI6MjA2MTA3OTQ3MH0.EymP7N-yMrCHVkBpzEG3sfBWckHjYxYkv9_DvOU6KCI</string>
	<key>SUPABASE_URL</key>
	<string>https://vlmwlvkaizgrcqzyonfy.supabase.co</string>
</dict>
</plist>
</file>

<file path="Picklet/PickletApp.swift">
//
//  MyAppApp.swift
//  MyApp
//
//  Created by al dente on 2025/04/12.
//

import SwiftUI

@main
struct PickletApp: App {
  @AppStorage("isLoggedIn") var isLoggedIn = false

  var body: some Scene {
    WindowGroup {
      if isLoggedIn && SupabaseService.shared.currentUser != nil {
        MainTabView()
      } else {
        LoginView()
      }
    }
  }
}
</file>

<file path="Picklet.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved">
{
  "originHash" : "15a4f8b25dc920ea2b643a29110bc3885ebd0af1cf374488f67945c07339a683",
  "pins" : [
    {
      "identity" : "sdwebimage",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/SDWebImage/SDWebImage.git",
      "state" : {
        "revision" : "cac9a55a3ae92478a2c95042dcc8d9695d2129ca",
        "version" : "5.21.0"
      }
    },
    {
      "identity" : "sdwebimageswiftui",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/SDWebImage/SDWebImageSwiftUI",
      "state" : {
        "revision" : "451c6dfd5ecec2cf626d1d9ca81c2d4a60355172",
        "version" : "3.1.3"
      }
    },
    {
      "identity" : "supabase-swift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/supabase/supabase-swift",
      "state" : {
        "revision" : "4c4f2a0483a794e9294ae0f550a63881e4ee1de9",
        "version" : "2.26.1"
      }
    },
    {
      "identity" : "swift-asn1",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-asn1.git",
      "state" : {
        "revision" : "a54383ada6cecde007d374f58f864e29370ba5c3",
        "version" : "1.3.2"
      }
    },
    {
      "identity" : "swift-clocks",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pointfreeco/swift-clocks",
      "state" : {
        "revision" : "cc46202b53476d64e824e0b6612da09d84ffde8e",
        "version" : "1.0.6"
      }
    },
    {
      "identity" : "swift-concurrency-extras",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pointfreeco/swift-concurrency-extras",
      "state" : {
        "revision" : "82a4ae7170d98d8538ec77238b7eb8e7199ef2e8",
        "version" : "1.3.1"
      }
    },
    {
      "identity" : "swift-crypto",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-crypto.git",
      "state" : {
        "revision" : "e8d6eba1fef23ae5b359c46b03f7d94be2f41fed",
        "version" : "3.12.3"
      }
    },
    {
      "identity" : "swift-http-types",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-http-types.git",
      "state" : {
        "revision" : "a0a57e949a8903563aba4615869310c0ebf14c03",
        "version" : "1.4.0"
      }
    },
    {
      "identity" : "xctest-dynamic-overlay",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pointfreeco/xctest-dynamic-overlay",
      "state" : {
        "revision" : "39de59b2d47f7ef3ca88a039dff3084688fe27f4",
        "version" : "1.5.2"
      }
    }
  ],
  "version" : 3
}
</file>

<file path="Picklet.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict/>
</plist>
</file>

<file path="Picklet.xcodeproj/project.xcworkspace/xcuserdata/reiji.xcuserdatad/Bookmarks/bookmarks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>top-level-items</key>
	<array>
		<dict>
			<key>destination</key>
			<dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>MyApp.xcodeproj</string>
					</dict>
				</dict>
				<key>type</key>
				<string>DVTDocumentLocation</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
	</array>
</dict>
</plist>
</file>

<file path="Picklet.xcodeproj/project.xcworkspace/xcuserdata/reiji.xcuserdatad/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>BuildLocationStyle</key>
	<string>UseAppPreferences</string>
	<key>CustomBuildLocationType</key>
	<string>RelativeToDerivedData</string>
	<key>DerivedDataLocationStyle</key>
	<string>Default</string>
	<key>ShowSharedSchemesAutomaticallyEnabled</key>
	<true/>
</dict>
</plist>
</file>

<file path="Picklet.xcodeproj/project.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
</file>

<file path="Picklet.xcodeproj/xcshareddata/xcschemes/MyApp.xcscheme">
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1620"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "B57C87D52DAA27A0001C2153"
               BuildableName = "Picklet.app"
               BlueprintName = "Picklet"
               ReferencedContainer = "container:Picklet.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "B57C87E52DAA27A1001C2153"
               BuildableName = "PickletTests.xctest"
               BlueprintName = "PickletTests"
               ReferencedContainer = "container:Picklet.xcodeproj">
            </BuildableReference>
         </TestableReference>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "B57C87EF2DAA27A1001C2153"
               BuildableName = "PickletUITests.xctest"
               BlueprintName = "PickletUITests"
               ReferencedContainer = "container:Picklet.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "B57C87D52DAA27A0001C2153"
            BuildableName = "Picklet.app"
            BlueprintName = "Picklet"
            ReferencedContainer = "container:Picklet.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "B57C87D52DAA27A0001C2153"
            BuildableName = "Picklet.app"
            BlueprintName = "Picklet"
            ReferencedContainer = "container:Picklet.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
</file>

<file path="Picklet.xcodeproj/xcuserdata/reiji.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist">
<?xml version="1.0" encoding="UTF-8"?>
<Bucket
   uuid = "9B6B3E3A-824B-482C-84F1-70FB2ADE8217"
   type = "1"
   version = "2.0">
</Bucket>
</file>

<file path="Picklet.xcodeproj/xcuserdata/reiji.xcuserdatad/xcschemes/xcschememanagement.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>MyApp.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
	<key>SuppressBuildableAutocreation</key>
	<dict>
		<key>B57C87D52DAA27A0001C2153</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>B57C87E52DAA27A1001C2153</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>B57C87EF2DAA27A1001C2153</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
	</dict>
</dict>
</plist>
</file>

<file path="Picklet.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXBuildFile section */
		B53EF51A2DBA8C8B00F5CA39 /* Auth in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF5192DBA8C8B00F5CA39 /* Auth */; };
		B53EF51C2DBA8C8B00F5CA39 /* Functions in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF51B2DBA8C8B00F5CA39 /* Functions */; };
		B53EF51E2DBA8C8B00F5CA39 /* PostgREST in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF51D2DBA8C8B00F5CA39 /* PostgREST */; };
		B53EF5202DBA8C8B00F5CA39 /* Realtime in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF51F2DBA8C8B00F5CA39 /* Realtime */; };
		B53EF5222DBA8C8B00F5CA39 /* Storage in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF5212DBA8C8B00F5CA39 /* Storage */; };
		B53EF5242DBA8C8B00F5CA39 /* Supabase in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF5232DBA8C8B00F5CA39 /* Supabase */; };
		B57CB8AD2DBB457300789BEF /* SDWebImageSwiftUI in Frameworks */ = {isa = PBXBuildFile; productRef = B57CB8AC2DBB457300789BEF /* SDWebImageSwiftUI */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		B57C87E72DAA27A1001C2153 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = B57C87CE2DAA27A0001C2153 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = B57C87D52DAA27A0001C2153;
			remoteInfo = MyApp;
		};
		B57C87F12DAA27A1001C2153 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = B57C87CE2DAA27A0001C2153 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = B57C87D52DAA27A0001C2153;
			remoteInfo = MyApp;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXFileReference section */
		B57C87D62DAA27A0001C2153 /* Picklet.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Picklet.app; sourceTree = BUILT_PRODUCTS_DIR; };
		B57C87E62DAA27A1001C2153 /* PickletTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = PickletTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		B57C87F02DAA27A1001C2153 /* PickletUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = PickletUITests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedBuildFileExceptionSet section */
		B53EF5382DBAA65500F5CA39 /* Exceptions for "Picklet" folder in "Picklet" target */ = {
			isa = PBXFileSystemSynchronizedBuildFileExceptionSet;
			membershipExceptions = (
				Info.plist,
			);
			target = B57C87D52DAA27A0001C2153 /* Picklet */;
		};
/* End PBXFileSystemSynchronizedBuildFileExceptionSet section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		B57C87D82DAA27A0001C2153 /* Picklet */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			exceptions = (
				B53EF5382DBAA65500F5CA39 /* Exceptions for "Picklet" folder in "Picklet" target */,
			);
			path = Picklet;
			sourceTree = "<group>";
		};
		B57C87E92DAA27A1001C2153 /* PickletTests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = PickletTests;
			sourceTree = "<group>";
		};
		B57C87F32DAA27A1001C2153 /* PickletUITests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = PickletUITests;
			sourceTree = "<group>";
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		B57C87D32DAA27A0001C2153 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				B57CB8AD2DBB457300789BEF /* SDWebImageSwiftUI in Frameworks */,
				B53EF51E2DBA8C8B00F5CA39 /* PostgREST in Frameworks */,
				B53EF51C2DBA8C8B00F5CA39 /* Functions in Frameworks */,
				B53EF5242DBA8C8B00F5CA39 /* Supabase in Frameworks */,
				B53EF51A2DBA8C8B00F5CA39 /* Auth in Frameworks */,
				B53EF5222DBA8C8B00F5CA39 /* Storage in Frameworks */,
				B53EF5202DBA8C8B00F5CA39 /* Realtime in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87E32DAA27A1001C2153 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87ED2DAA27A1001C2153 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		B53EF5182DBA8C8B00F5CA39 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		B57C87CD2DAA27A0001C2153 = {
			isa = PBXGroup;
			children = (
				B57C87D82DAA27A0001C2153 /* Picklet */,
				B57C87E92DAA27A1001C2153 /* PickletTests */,
				B57C87F32DAA27A1001C2153 /* PickletUITests */,
				B53EF5182DBA8C8B00F5CA39 /* Frameworks */,
				B57C87D72DAA27A0001C2153 /* Products */,
			);
			sourceTree = "<group>";
		};
		B57C87D72DAA27A0001C2153 /* Products */ = {
			isa = PBXGroup;
			children = (
				B57C87D62DAA27A0001C2153 /* Picklet.app */,
				B57C87E62DAA27A1001C2153 /* PickletTests.xctest */,
				B57C87F02DAA27A1001C2153 /* PickletUITests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		B57C87D52DAA27A0001C2153 /* Picklet */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = B57C87FA2DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "Picklet" */;
			buildPhases = (
				B57C87D22DAA27A0001C2153 /* Sources */,
				B57C87D32DAA27A0001C2153 /* Frameworks */,
				B57C87D42DAA27A0001C2153 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				B57C87D82DAA27A0001C2153 /* Picklet */,
			);
			name = Picklet;
			packageProductDependencies = (
				B53EF5192DBA8C8B00F5CA39 /* Auth */,
				B53EF51B2DBA8C8B00F5CA39 /* Functions */,
				B53EF51D2DBA8C8B00F5CA39 /* PostgREST */,
				B53EF51F2DBA8C8B00F5CA39 /* Realtime */,
				B53EF5212DBA8C8B00F5CA39 /* Storage */,
				B53EF5232DBA8C8B00F5CA39 /* Supabase */,
				B57CB8AC2DBB457300789BEF /* SDWebImageSwiftUI */,
			);
			productName = MyApp;
			productReference = B57C87D62DAA27A0001C2153 /* Picklet.app */;
			productType = "com.apple.product-type.application";
		};
		B57C87E52DAA27A1001C2153 /* PickletTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = B57C87FD2DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "PickletTests" */;
			buildPhases = (
				B57C87E22DAA27A1001C2153 /* Sources */,
				B57C87E32DAA27A1001C2153 /* Frameworks */,
				B57C87E42DAA27A1001C2153 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				B57C87E82DAA27A1001C2153 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				B57C87E92DAA27A1001C2153 /* PickletTests */,
			);
			name = PickletTests;
			packageProductDependencies = (
			);
			productName = MyAppTests;
			productReference = B57C87E62DAA27A1001C2153 /* PickletTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		B57C87EF2DAA27A1001C2153 /* PickletUITests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = B57C88002DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "PickletUITests" */;
			buildPhases = (
				B57C87EC2DAA27A1001C2153 /* Sources */,
				B57C87ED2DAA27A1001C2153 /* Frameworks */,
				B57C87EE2DAA27A1001C2153 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				B57C87F22DAA27A1001C2153 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				B57C87F32DAA27A1001C2153 /* PickletUITests */,
			);
			name = PickletUITests;
			packageProductDependencies = (
			);
			productName = MyAppUITests;
			productReference = B57C87F02DAA27A1001C2153 /* PickletUITests.xctest */;
			productType = "com.apple.product-type.bundle.ui-testing";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		B57C87CE2DAA27A0001C2153 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1620;
				LastUpgradeCheck = 1620;
				TargetAttributes = {
					B57C87D52DAA27A0001C2153 = {
						CreatedOnToolsVersion = 16.2;
					};
					B57C87E52DAA27A1001C2153 = {
						CreatedOnToolsVersion = 16.2;
						TestTargetID = B57C87D52DAA27A0001C2153;
					};
					B57C87EF2DAA27A1001C2153 = {
						CreatedOnToolsVersion = 16.2;
						TestTargetID = B57C87D52DAA27A0001C2153;
					};
				};
			};
			buildConfigurationList = B57C87D12DAA27A0001C2153 /* Build configuration list for PBXProject "Picklet" */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = B57C87CD2DAA27A0001C2153;
			minimizedProjectReferenceProxies = 1;
			packageReferences = (
				B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */,
				B53EF53B2DBB3F6700F5CA39 /* XCRemoteSwiftPackageReference "SDWebImageSwiftUI" */,
			);
			preferredProjectObjectVersion = 77;
			productRefGroup = B57C87D72DAA27A0001C2153 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				B57C87D52DAA27A0001C2153 /* Picklet */,
				B57C87E52DAA27A1001C2153 /* PickletTests */,
				B57C87EF2DAA27A1001C2153 /* PickletUITests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		B57C87D42DAA27A0001C2153 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87E42DAA27A1001C2153 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87EE2DAA27A1001C2153 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		B57C87D22DAA27A0001C2153 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87E22DAA27A1001C2153 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87EC2DAA27A1001C2153 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		B57C87E82DAA27A1001C2153 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = B57C87D52DAA27A0001C2153 /* Picklet */;
			targetProxy = B57C87E72DAA27A1001C2153 /* PBXContainerItemProxy */;
		};
		B57C87F22DAA27A1001C2153 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = B57C87D52DAA27A0001C2153 /* Picklet */;
			targetProxy = B57C87F12DAA27A1001C2153 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin XCBuildConfiguration section */
		B57C87F82DAA27A1001C2153 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		B57C87F92DAA27A1001C2153 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		B57C87FB2DAA27A1001C2153 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"Picklet/Preview Content\"";
				DEVELOPMENT_TEAM = 8WZMDG8UJ5;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = Picklet/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = Picklet;
				INFOPLIST_KEY_LSSupportsOpeningDocumentsInPlace = YES;
				INFOPLIST_KEY_NSCameraUsageDescription = "„Ç´„É°„É©„ÅßÊíÆÂΩ±„Åô„Çã„Åü„ÇÅ„Å´„Ç´„É°„É©„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";
				INFOPLIST_KEY_NSLocationWhenInUseUsageDescription = "Â§©Ê∞óÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã„Åü„ÇÅ„Å´‰ΩçÁΩÆÊÉÖÂ†±„Çí‰ΩøÁî®„Åó„Åæ„Åô";
				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "ÂÜôÁúü„ÇíÈÅ∏Êäû„Åô„Çã„Åü„ÇÅ„Å´„Éï„Ç©„Éà„É©„Ç§„Éñ„É©„É™„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = UIInterfaceOrientationPortrait;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.Picklet;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		B57C87FC2DAA27A1001C2153 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"Picklet/Preview Content\"";
				DEVELOPMENT_TEAM = 8WZMDG8UJ5;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = Picklet/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = Picklet;
				INFOPLIST_KEY_LSSupportsOpeningDocumentsInPlace = YES;
				INFOPLIST_KEY_NSCameraUsageDescription = "„Ç´„É°„É©„ÅßÊíÆÂΩ±„Åô„Çã„Åü„ÇÅ„Å´„Ç´„É°„É©„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";
				INFOPLIST_KEY_NSLocationWhenInUseUsageDescription = "Â§©Ê∞óÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã„Åü„ÇÅ„Å´‰ΩçÁΩÆÊÉÖÂ†±„Çí‰ΩøÁî®„Åó„Åæ„Åô";
				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "ÂÜôÁúü„ÇíÈÅ∏Êäû„Åô„Çã„Åü„ÇÅ„Å´„Éï„Ç©„Éà„É©„Ç§„Éñ„É©„É™„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = UIInterfaceOrientationPortrait;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.Picklet;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
		B57C87FE2DAA27A1001C2153 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 8WZMDG8UJ5;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.PickletTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Picklet.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Picklet";
			};
			name = Debug;
		};
		B57C87FF2DAA27A1001C2153 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 8WZMDG8UJ5;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.PickletTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Picklet.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Picklet";
			};
			name = Release;
		};
		B57C88012DAA27A1001C2153 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.PickletUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_TARGET_NAME = Picklet;
			};
			name = Debug;
		};
		B57C88022DAA27A1001C2153 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.PickletUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_TARGET_NAME = Picklet;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		B57C87D12DAA27A0001C2153 /* Build configuration list for PBXProject "Picklet" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				B57C87F82DAA27A1001C2153 /* Debug */,
				B57C87F92DAA27A1001C2153 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		B57C87FA2DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "Picklet" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				B57C87FB2DAA27A1001C2153 /* Debug */,
				B57C87FC2DAA27A1001C2153 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		B57C87FD2DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "PickletTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				B57C87FE2DAA27A1001C2153 /* Debug */,
				B57C87FF2DAA27A1001C2153 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		B57C88002DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "PickletUITests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				B57C88012DAA27A1001C2153 /* Debug */,
				B57C88022DAA27A1001C2153 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */

/* Begin XCRemoteSwiftPackageReference section */
		B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/supabase/supabase-swift";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 2.5.1;
			};
		};
		B53EF53B2DBB3F6700F5CA39 /* XCRemoteSwiftPackageReference "SDWebImageSwiftUI" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/SDWebImage/SDWebImageSwiftUI";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 3.1.3;
			};
		};
/* End XCRemoteSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		B53EF5192DBA8C8B00F5CA39 /* Auth */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = Auth;
		};
		B53EF51B2DBA8C8B00F5CA39 /* Functions */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = Functions;
		};
		B53EF51D2DBA8C8B00F5CA39 /* PostgREST */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = PostgREST;
		};
		B53EF51F2DBA8C8B00F5CA39 /* Realtime */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = Realtime;
		};
		B53EF5212DBA8C8B00F5CA39 /* Storage */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = Storage;
		};
		B53EF5232DBA8C8B00F5CA39 /* Supabase */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = Supabase;
		};
		B57CB8AC2DBB457300789BEF /* SDWebImageSwiftUI */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF53B2DBB3F6700F5CA39 /* XCRemoteSwiftPackageReference "SDWebImageSwiftUI" */;
			productName = SDWebImageSwiftUI;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = B57C87CE2DAA27A0001C2153 /* Project object */;
}
</file>

<file path="PickletTests/PickletTests.swift">
//
//  MyAppTests.swift
//  MyAppTests
//
//  Created by al dente on 2025/04/12.
//

import Testing

@testable import MyApp

struct PickletTests {

  @Test func example() async throws {
    // Write your test here and use APIs like `#expect(...)` to check expected conditions.
  }

  @Test func testLogin() async throws {
    let viewModel = LoginViewModel()
    viewModel.email = "test@example.com"
    viewModel.password = "password123"

    await viewModel.login()

    XCTAssertTrue(viewModel.isLoggedIn)
    XCTAssertNil(viewModel.errorMessage)
  }

}
</file>

<file path="PickletUITests/PickletUITests.swift">
//
//  MyAppUITests.swift
//  MyAppUITests
//
//  Created by al dente on 2025/04/12.
//

import XCTest

final class PickletUITests: XCTestCase {

  override func setUpWithError() throws {
    // Put setup code here. This method is called before the invocation of each test method in the class.

    // In UI tests it is usually best to stop immediately when a failure occurs.
    continueAfterFailure = false

    // In UI tests it‚Äôs important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
  }

  override func tearDownWithError() throws {
    // Put teardown code here. This method is called after the invocation of each test method in the class.
  }

  @MainActor
  func testExample() throws {
    // UI tests must launch the application that they test.
    let app = XCUIApplication()
    app.launch()

    // Use XCTAssert and related functions to verify your tests produce the correct results.
  }

  @MainActor
  func testLaunchPerformance() throws {
    if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *) {
      // This measures how long it takes to launch your application.
      measure(metrics: [XCTApplicationLaunchMetric()]) {
        XCUIApplication().launch()
      }
    }
  }
}
</file>

<file path="PickletUITests/PickletUITestsLaunchTests.swift">
//
//  MyAppUITestsLaunchTests.swift
//  MyAppUITests
//
//  Created by al dente on 2025/04/12.
//

import XCTest

final class PickletUITestsLaunchTests: XCTestCase {

  override class var runsForEachTargetApplicationUIConfiguration: Bool {
    true
  }

  override func setUpWithError() throws {
    continueAfterFailure = false
  }

  @MainActor
  func testLaunch() throws {
    let app = XCUIApplication()
    app.launch()

    // Insert steps here to perform after app launch but before taking a screenshot,
    // such as logging into a test account or navigating somewhere in the app

    let attachment = XCTAttachment(screenshot: app.screenshot())
    attachment.name = "Launch Screen"
    attachment.lifetime = .keepAlways
    add(attachment)
  }
}
</file>

<file path=".gitattributes">
*.mlmodel filter=lfs diff=lfs merge=lfs -text
</file>

<file path=".gitignore">
.DS_Store
</file>

<file path=".swiftlint.yml">
disabled_rules:
  - trailing_whitespace
  - line_length
  - force_cast

opt_in_rules:
  - force_unwrapping
  - empty_count
</file>

<file path="run_app.sh">
#!/bin/bash

# Ë®≠ÂÆöÈ†ÖÁõÆÔºà„ÅÇ„Å™„Åü„ÅÆÁí∞Â¢É„Å´Âêà„Çè„Åõ„Å¶Â§âÊõ¥Ôºâ
SCHEME="MyApp"  # ‚Üê Xcode„ÅÆ„Çπ„Ç≠„Éº„É†Âêç
BUNDLE_ID="com.example.MyApp"  # ‚Üê „ÅÇ„Å™„Åü„ÅÆ„Ç¢„Éó„É™„ÅÆ„Éê„É≥„Éâ„É´ID
DEVICE_UDID="926C9EF3-F840-444D-8361-6B802B550C23"

echo "üîÑ „Ç∑„Éü„É•„É¨„Éº„Çø„ÇíËµ∑Âãï‰∏≠: iPhone 16 ($DEVICE_UDID)"
xcrun simctl boot "$DEVICE_UDID" || echo "üü° Êó¢„Å´Ëµ∑ÂãïÊ∏à„Åø„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì"

# „Éì„É´„Éâ
echo "üõ† „Ç¢„Éó„É™„Çí„Éì„É´„Éâ‰∏≠..."
xcodebuild -scheme "$SCHEME" -destination "id=$DEVICE_UDID" build || {
    echo "‚ùå „Éì„É´„ÉâÂ§±Êïó"
    exit 1
}

# .app „ÅÆÂ†¥ÊâÄ„ÇíËá™Âãï„ÅßÊé¢„ÅôÔºàÊúÄ„ÇÇÊúÄËøë„ÅÆ„Éì„É´„ÉâÔºâ
APP_PATH=$(find ~/Library/Developer/Xcode/DerivedData -type d -name "$SCHEME.app" | sort -r | head -n 1)

if [ -z "$APP_PATH" ]; then
    echo "‚ùå .app „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì"
    exit 1
fi

# „Ç§„É≥„Çπ„Éà„Éº„É´„Å®Ëµ∑Âãï
echo "üì≤ „Ç¢„Éó„É™„Çí„Ç∑„Éü„É•„É¨„Éº„Çø„Å´„Ç§„É≥„Çπ„Éà„Éº„É´: $APP_PATH"
xcrun simctl install "$DEVICE_UDID" "$APP_PATH"

echo "üöÄ „Ç¢„Éó„É™„ÇíËµ∑Âãï: $BUNDLE_ID"
xcrun simctl launch "$DEVICE_UDID" "$BUNDLE_ID"
</file>

<file path="run_device.sh">
#!/bin/bash

# === ÂøÖÈ†àË®≠ÂÆö ===============================
SCHEME="MyApp"                      # „ÅÇ„Å™„Åü„ÅÆXcode„ÅÆ„Çπ„Ç≠„Éº„É†Âêç„Å´Â§âÊõ¥
BUNDLE_ID="com.example.MyApp"       # „ÅÇ„Å™„Åü„ÅÆ„Ç¢„Éó„É™„ÅÆ„Éê„É≥„Éâ„É´ID„Å´Â§âÊõ¥
DEVICE_UDID="00008101-000968C90E28001E" # „ÅÇ„Å™„Åü„ÅÆiPhone„ÅÆUDID„Å´Â∑Æ„ÅóÊõø„Åà
# ============================================

echo "üîß ÂÆüÊ©ü„Éì„É´„ÉâÔºÜ„Ç§„É≥„Çπ„Éà„Éº„É´ÈñãÂßãÔºàUDID: $DEVICE_UDIDÔºâ"

# „Éì„É´„ÉâÔºÜÁΩ≤ÂêçÔºà„Éó„É≠„Éì„Ç∏„Éß„Éã„É≥„Ç∞„Éó„É≠„Éï„Ç°„Ç§„É´Ëá™ÂãïÂØæÂøúÔºâ
xcodebuild -scheme "$SCHEME" \
  -destination "platform=iOS,id=$DEVICE_UDID" \
  -allowProvisioningUpdates \
  build || {
    echo "‚ùå „Éì„É´„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü"
    exit 1
}

# .app „ÅÆÊ§úÁ¥¢ÔºàÊúÄÊñ∞„ÅÆ„Éì„É´„ÉâÊàêÊûúÁâ©Ôºâ
APP_PATH=$(find ~/Library/Developer/Xcode/DerivedData -name "$SCHEME.app" | sort -r | head -n 1)

if [ -z "$APP_PATH" ]; then
    echo "‚ùå .app „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì"
    exit 1
fi

echo "üì≤ „Ç§„É≥„Çπ„Éà„Éº„É´‰∏≠: $APP_PATH"
xcrun simctl install "$DEVICE_UDID" "$APP_PATH" || {
    echo "‚ùå „Ç§„É≥„Çπ„Éà„Éº„É´„Å´Â§±Êïó„Åó„Åæ„Åó„Åü"
    exit 1
}

echo "üöÄ Ëµ∑Âãï‰∏≠: $BUNDLE_ID"
xcrun simctl launch "$DEVICE_UDID" "$BUNDLE_ID" || {
    echo "‚ùå Ëµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü"
    exit 1
}
</file>

</files>
