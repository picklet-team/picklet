This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
Picklet/
  Extensions/
    UIImage+FixOrientation.swift
    UIImage+FlippedHorizontally.swift
    UIImage+InvertedMask.swift
    UIImage+Normalized.swift
    UIImage+PixelBuffer.swift
    UIImage+ResizedAspectFit.swift
    UIImage+Rotate.swift
  Models/
    Clothing.swift
    ClothingImage.swift
    LocationManager.swift
    Weather.swift
  Preview Content/
    Preview Assets.xcassets/
      Contents.json
  Resources/
    Assets.xcassets/
      AccentColor.colorset/
        Contents.json
      AppIcon.appiconset/
        Contents.json
      Contents.json
  Services/
    CoreMLService.swift
    ImageProcessor.swift
    SupabaseService.swift
    WeatherService.swift
  Utilities/
    ImagePicker.swift
  ViewModels/
    ClothingViewModel.swift
    LibraryPickerViewModel.swift
    LoginViewModel.swift
  Views/
    Capture/
      Camera/
        CameraPreviewController.swift
        CameraPreviewView.swift
        CameraSquarePreviewView.swift
      Library/
        LibraryPickerView.swift
        PhotoLibraryPickerView.swift
      CaptureOrLibraryView.swift
      ModeSwitchBarView.swift
    Components/
      PrimaryActionButton.swift
    Dock/
      ClothingDockView.swift
    Edit/
      Image/
        ImageEditView.swift
        ImageView.swift
      ClothingEditView.swift
    ClothingCropEditView.swift
    ClothingCropPreviewView.swift
    ClothingDetailView.swift
    ClothingItemView.swift
    ClothingListView.swift
    EditableImageSet.swift
    LocationTestView.swift
    LoginView.swift
    MainTabView.swift
    MaskEditCanvasView.swift
    SettingsView.swift
    WeatherLoaderView.swift
    WeatherView.swift
  Info.plist
  PickletApp.swift
Picklet.xcodeproj/
  project.xcworkspace/
    xcshareddata/
      swiftpm/
        Package.resolved
      WorkspaceSettings.xcsettings
    xcuserdata/
      reiji.xcuserdatad/
        Bookmarks/
          bookmarks.plist
        WorkspaceSettings.xcsettings
    contents.xcworkspacedata
  xcshareddata/
    xcschemes/
      MyApp.xcscheme
  xcuserdata/
    reiji.xcuserdatad/
      xcdebugger/
        Breakpoints_v2.xcbkptlist
      xcschemes/
        xcschememanagement.plist
  project.pbxproj
PickletTests/
  PickletTests.swift
PickletUITests/
  PickletUITests.swift
  PickletUITestsLaunchTests.swift
.gitattributes
.gitignore
.swiftlint.yml
run_app.sh
run_device.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Picklet/Extensions/UIImage+FixOrientation.swift">
//
//  UIImage+FixOrientation.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import UIKit

extension UIImage {
  /// 画像の上下左右の向きを .up に正規化する
  func fixedOrientation() -> UIImage {
    if imageOrientation == .up {
      return self
    }

    UIGraphicsBeginImageContextWithOptions(size, false, scale)
    draw(in: CGRect(origin: .zero, size: size))
    let normalizedImage = UIGraphicsGetImageFromCurrentImageContext()!
    UIGraphicsEndImageContext()
    return normalizedImage
  }
}
</file>

<file path="Picklet/Extensions/UIImage+FlippedHorizontally.swift">
//
//  UIImage+FlippedHorizontally.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import UIKit

extension UIImage {
  func flippedHorizontally() -> UIImage? {
    UIGraphicsBeginImageContextWithOptions(size, false, scale)
    let context = UIGraphicsGetCurrentContext()
    context?.translateBy(x: 0, y: size.height)
    context?.scaleBy(x: 1, y: -1)
    draw(in: CGRect(origin: .zero, size: size))
    let flippedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return flippedImage
  }
}
</file>

<file path="Picklet/Extensions/UIImage+InvertedMask.swift">
//
//  UIImage+InvertedMask.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import CoreImage
import UIKit

extension UIImage {
  func invertedMask() -> UIImage? {
    guard let ciImage = CIImage(image: self) else { return nil }

    let filter = CIFilter(name: "CIColorInvert")
    filter?.setValue(ciImage, forKey: kCIInputImageKey)

    guard let outputImage = filter?.outputImage else { return nil }
    let context = CIContext()
    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {
      return UIImage(cgImage: cgImage)
    }
    return nil
  }
}
</file>

<file path="Picklet/Extensions/UIImage+Normalized.swift">
//
//  UIImage+Normalized.swift
//  MyApp
//
//  Created by al dente on 2025/04/29.
//

import UIKit

extension UIImage {
  func normalized() -> UIImage {
    if self.imageOrientation == .up {
      return self  // 問題なし
    }

    UIGraphicsBeginImageContextWithOptions(self.size, false, self.scale)
    self.draw(in: CGRect(origin: .zero, size: self.size))
    let normalizedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return normalizedImage ?? self
  }
}
</file>

<file path="Picklet/Extensions/UIImage+PixelBuffer.swift">
//
//  UIImage+PixelBuffer.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import UIKit

extension UIImage {
  func pixelBuffer(width: Int, height: Int) -> CVPixelBuffer? {
    let attrs =
      [
        kCVPixelBufferCGImageCompatibilityKey: true,
        kCVPixelBufferCGBitmapContextCompatibilityKey: true,
      ] as CFDictionary
    var pixelBuffer: CVPixelBuffer?

    let status = CVPixelBufferCreate(
      kCFAllocatorDefault,
      width,
      height,
      kCVPixelFormatType_32ARGB,
      attrs,
      &pixelBuffer)

    guard status == kCVReturnSuccess, let buffer = pixelBuffer else { return nil }

    CVPixelBufferLockBaseAddress(buffer, .readOnly)
    let context = CGContext(
      data: CVPixelBufferGetBaseAddress(buffer),
      width: width,
      height: height,
      bitsPerComponent: 8,
      bytesPerRow: CVPixelBufferGetBytesPerRow(buffer),
      space: CGColorSpaceCreateDeviceRGB(),
      bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue)
    guard let cgImage = self.cgImage else { return nil }

    context?.saveGState()
    context?.translateBy(x: 0, y: CGFloat(height))
    context?.scaleBy(x: 1.0, y: -1.0)  // 上下反転で正しい方向に描画される
    context?.draw(cgImage, in: CGRect(x: 0, y: 0, width: width, height: height))
    context?.restoreGState()

    CVPixelBufferUnlockBaseAddress(buffer, .readOnly)

    return buffer
  }

  convenience init?(pixelBuffer: CVPixelBuffer) {
    let ciImage = CIImage(cvPixelBuffer: pixelBuffer)
    let context = CIContext()
    guard let cgImage = context.createCGImage(ciImage, from: ciImage.extent) else { return nil }
    self.init(cgImage: cgImage)
  }
}
</file>

<file path="Picklet/Extensions/UIImage+ResizedAspectFit.swift">
//
//  UIImage+Resized.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import UIKit

extension UIImage {
  /// 元画像をアスペクト比を保ったままリサイズし、透明な背景で正方形にパディングする
  func resizedAspectFitWithTransparentPadding(to targetSize: CGSize) -> UIImage? {
    // 1. 元画像とターゲットサイズの比率を計算
    let widthRatio = targetSize.width / size.width
    let heightRatio = targetSize.height / size.height

    // 2. 縦横の小さい方に合わせてスケール
    let scaleFactor = min(widthRatio, heightRatio)

    // 3. リサイズ後の画像サイズを決定
    let resizedSize = CGSize(
      width: size.width * scaleFactor,
      height: size.height * scaleFactor
    )

    // 4. 描画コンテキストをターゲットサイズで作成（背景は透明）
    UIGraphicsBeginImageContextWithOptions(targetSize, false, scale)

    // 5. リサイズ後の画像を中央に配置
    let origin = CGPoint(
      x: (targetSize.width - resizedSize.width) / 2,
      y: (targetSize.height - resizedSize.height) / 2
    )
    self.draw(in: CGRect(origin: origin, size: resizedSize))

    // 6. コンテキストから新しいUIImageを取り出す
    let resultImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return resultImage
  }
  /// 元画像サイズにマスクを中央合わせでリサイズする
  func resizedMaskCentered(to originalSize: CGSize) -> UIImage? {
    UIGraphicsBeginImageContextWithOptions(originalSize, false, scale)

    let maskSize = self.size.width  // 1024前提
    let targetLongSide = max(originalSize.width, originalSize.height)
    let scaleFactor = targetLongSide / maskSize

    let newMaskSize = CGSize(
      width: self.size.width * scaleFactor,
      height: self.size.height * scaleFactor
    )

    let origin = CGPoint(
      x: (originalSize.width - newMaskSize.width) / 2,
      y: (originalSize.height - newMaskSize.height) / 2
    )

    self.draw(in: CGRect(origin: origin, size: newMaskSize))

    let resizedMask = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return resizedMask
  }
}
</file>

<file path="Picklet/Extensions/UIImage+Rotate.swift">
//
//  UIImage+Rotate.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import UIKit

extension UIImage {
  /// 任意の角度（度数）で画像を回転する
  func rotated(byDegrees degrees: CGFloat) -> UIImage? {
    let radians = degrees * (.pi / 180)
    let newSize = CGRect(origin: .zero, size: size)
      .applying(CGAffineTransform(rotationAngle: radians))
      .integral.size

    UIGraphicsBeginImageContextWithOptions(newSize, false, scale)
    guard let context = UIGraphicsGetCurrentContext(), let cgImage = self.cgImage else {
      return nil
    }

    context.translateBy(x: newSize.width / 2, y: newSize.height / 2)
    context.rotate(by: radians)
    context.scaleBy(x: 1.0, y: -1.0)  // UIKitの上下反転補正

    context.draw(
      cgImage,
      in: CGRect(
        x: -size.width / 2, y: -size.height / 2,
        width: size.width, height: size.height))

    let rotatedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return rotatedImage
  }
}
</file>

<file path="Picklet/Models/Clothing.swift">
//
//  Clothing.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

// Models/Clothing.swift
import Foundation

struct Clothing: Codable, Identifiable, Equatable {
  let id: UUID
  let user_id: UUID
  var name: String
  var category: String
  var color: String
  let created_at: String
  let updated_at: String
}
</file>

<file path="Picklet/Models/ClothingImage.swift">
//
//  ClothingImage.swift
//  MyApp
//
//  Created by al dente on 2025/04/27.
//

import Foundation

struct ClothingImage: Identifiable, Codable {
  let id: UUID
  let clothing_id: UUID
  let user_id: UUID
  let original_url: String
  let mask_url: String?
  let result_url: String?
  let created_at: String
  let updated_at: String
}
</file>

<file path="Picklet/Models/LocationManager.swift">
//
//  LocationManager.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import CoreLocation
import SwiftUI

class LocationManager: NSObject, ObservableObject, CLLocationManagerDelegate {
  private let locationManager = CLLocationManager()

  @Published var currentLocation: CLLocation?
  @Published var placemark: CLPlacemark?
  @Published var locationError: Error?

  override init() {
    super.init()
    locationManager.delegate = self
    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters
    locationManager.requestWhenInUseAuthorization()
    locationManager.startUpdatingLocation()
  }

  func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    guard let location = locations.first else { return }
    self.currentLocation = location

    let geocoder = CLGeocoder()
    geocoder.reverseGeocodeLocation(location) { placemarks, error in
      if let error = error {
        self.locationError = error
        return
      }
      self.placemark = placemarks?.first
    }
  }

  func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
    self.locationError = error
  }
}
</file>

<file path="Picklet/Models/Weather.swift">
//
//  Weather.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

struct Weather: Codable {
  let city: String
  let date: String  // yyyy-MM-dd
  let temperature: Double
  let condition: String  // 表示用（日本語: 曇りなど）
  let icon: String  // OpenWeatherのアイコン名
  let updated_at: String  // ISO8601形式の日時（キャッシュの有効性判定にも使える）
}
</file>

<file path="Picklet/Preview Content/Preview Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Picklet/Resources/Assets.xcassets/AccentColor.colorset/Contents.json">
{
  "colors": [
    {
      "color": {
        "color-space": "srgb",
        "components": {
          "red": "0.0",
          "green": "0.478431",
          "blue": "1.0",
          "alpha": "1.0"
        }
      },
      "idiom": "universal"
    }
  ],
  "info": {
    "author": "xcode",
    "version": 1
  }
}
</file>

<file path="Picklet/Resources/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "filename" : "picklet.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Picklet/Resources/Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Picklet/Services/CoreMLService.swift">
//
//  CoreMLService.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import CoreML
import SwiftUI

class CoreMLService {
  static let shared = CoreMLService()

  private let model: ISNet

  init() {
    self.model = try! ISNet(configuration: MLModelConfiguration())
  }

  func processImageSet(imageSet: EditableImageSet?) async -> EditableImageSet? {
    // ① imageSet自体の存在をチェック
    guard var set = imageSet else {
      print("❌ imageSet is nil")
      return nil
    }

    // ② original が nil なら URL からダウンロード
    if set.original == nil,
      let urlStr = set.originalUrl,
      let url = URL(string: urlStr)
    {
      do {
        let (data, _) = try await URLSession.shared.data(from: url)
        if let image = UIImage(data: data) {
          set.original = image
        } else {
          print("❌ failed to decode image from data")
          return nil
        }
      } catch {
        print("❌ failed to download image:", error)
        return nil
      }
    }

    // ③ original が still nil の場合 → 処理不可
    guard let original = set.original else {
      print("❌ original image not available")
      return nil
    }

    // ④ CoreML によるマスク推論
    guard let mask = await CoreMLService.shared.predictMask(for: original) else {
      print("❌ mask prediction failed")
      return nil
    }

    // ⑤ マスクを使って切り抜き画像を生成
    guard let result = ImageProcessor.applyMask(original: original, mask: mask) else {
      print("❌ mask application failed")
      return nil
    }

    // ⑥ 加工結果を保存して返す
    set.mask = mask
    set.result = result
    return set
  }

  func processImage(image: UIImage) async -> UIImage? {
    // 1. 推論
    guard let mask = await CoreMLService.shared.predictMask(for: image) else {
      print("❌ mask prediction failed")
      return nil
    }

    guard let result = ImageProcessor.applyMask(original: image, mask: mask) else {
      print("❌ mask application failed")
      return nil
    }
    return result
  }

  func predictMask(
    for image: UIImage,
    flipHorizontally: Bool = true
  ) async -> UIImage? {
    let targetSize = CGSize(width: 1024, height: 1024)

    // 1. 推論用にリサイズ
    guard let resizedInput = image.resizedAspectFitWithTransparentPadding(to: targetSize),
      let pixelBuffer = resizedInput.pixelBuffer(
        width: Int(targetSize.width), height: Int(targetSize.height))
    else {
      print("❌ pixelBuffer生成失敗")
      return nil
    }

    do {
      // 2. 推論
      let output = try model.prediction(x_1: pixelBuffer)
      guard var maskImage = UIImage(pixelBuffer: output.activation_out) else {
        print("❌ マスク画像作成失敗")
        return nil
      }

      // ---ここからマスク加工---

      // 4. マスクを元画像サイズにリサイズ（元画像と同じ）
      guard let resizedMask = maskImage.resizedMaskCentered(to: image.size) else {
        print("❌ マスクリサイズ失敗")
        return nil
      }

      maskImage = resizedMask

      // 5. マスクを左右反転（必要なら）
      if flipHorizontally {
        maskImage = maskImage.flippedHorizontally() ?? maskImage
      }

      // 6. マスクを白黒反転
      guard let invertedMask = maskImage.invertedMask() else {
        print("❌ マスク白黒反転失敗")
        return nil
      }

      // ---マスク加工ここまで---

      return invertedMask

    } catch {
      print("❌ 推論失敗: \(error.localizedDescription)")
      return nil
    }
  }

}
</file>

<file path="Picklet/Services/ImageProcessor.swift">
//
//  ImageProcessor.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import CoreImage
import UIKit

enum ImageProcessor {
  /// CIImageでマスク画像をアルファに変換 → 合成
  static func applyMask(original: UIImage, mask: UIImage) -> UIImage? {
    guard let ciOriginal = CIImage(image: original),
      let ciMask = CIImage(image: mask)
    else { return nil }

    let alphaMask =
      ciMask
      .applyingFilter("CIColorInvert")
      .applyingFilter("CIMaskToAlpha")

    let composited =
      ciOriginal
      .applyingFilter(
        "CIBlendWithAlphaMask",
        parameters: [
          "inputMaskImage": alphaMask
        ])

    let context = CIContext()
    guard let output = context.createCGImage(composited, from: ciOriginal.extent) else {
      return nil
    }

    return UIImage(cgImage: output)
  }

  /// 完成画像とマスクを合成して、マスク範囲を黒く強調するビジュアライズ画像を作る
  static func visualizeMaskOnOriginal(original: UIImage, mask: UIImage) -> UIImage? {
    guard let ciOriginal = CIImage(image: original),
      let ciMask = CIImage(image: mask)
    else {
      return nil
    }

    // マスクの白い部分だけを透明にする（マスクが黒いところが残る）
    let alphaMask =
      ciMask
      .applyingFilter("CIColorInvert")
      .applyingFilter("CIMaskToAlpha")

    let maskedImage =
      ciOriginal
      .applyingFilter(
        "CIBlendWithAlphaMask",
        parameters: [
          "inputMaskImage": alphaMask
        ]
      )
      .applyingFilter(
        "CIColorControls",
        parameters: [
          "inputBrightness": -1.0  // 黒くする
        ])

    let context = CIContext()
    guard let output = context.createCGImage(maskedImage, from: ciOriginal.extent) else {
      return nil
    }

    return UIImage(cgImage: output)
  }

}
</file>

<file path="Picklet/Services/SupabaseService.swift">
//
//  SupabaseService.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import Foundation
import PostgREST
import Storage
import Supabase
// Services/SupabaseService.swift
import SwiftUI
import UIKit

extension PostgrestResponse {
  func decoded<U: Decodable>(to type: U.Type) throws -> U {
    let decoder = JSONDecoder()
    return try decoder.decode(U.self, from: self.data)
  }
}

class SupabaseService {
  @AppStorage("isLoggedIn") var isLoggedIn = false

  static let shared = SupabaseService()

  internal let client: SupabaseClient
  private let storageBucketName = "clothes-images"

  private init() {
    guard
      let urlString = Bundle.main.object(forInfoDictionaryKey: "SUPABASE_URL") as? String,
      let key = Bundle.main.object(forInfoDictionaryKey: "SUPABASE_KEY") as? String,
      let url = URL(string: urlString)
    else {
      fatalError("❌ Supabaseの設定がInfo.plistにありません")
    }

    self.client = SupabaseClient(supabaseURL: url, supabaseKey: key)
  }

  var currentUser: User? {
    client.auth.currentUser
  }

  // MARK: - 認証

  func signIn(email: String, password: String) async throws {
    try await client.auth.signIn(email: email, password: password)
    isLoggedIn = true
  }

  func signUp(email: String, password: String) async throws {
    try await client.auth.signUp(email: email, password: password)
    isLoggedIn = true
  }

  func signOut() async throws {
    try await client.auth.signOut()
    isLoggedIn = false
  }

  // MARK: - 服画像データ

  func fetchImages(for clothingId: UUID) async throws -> [ClothingImage] {
    return
      try await client
      .from("clothing_images")
      .select("*")
      .eq("clothing_id", value: clothingId.uuidString)
      .execute()
      .decoded(to: [ClothingImage].self)
  }

  func addImage(
    for clothingId: UUID, originalUrl: String, maskUrl: String? = nil, resultUrl: String? = nil
  ) async throws {
    guard let user = currentUser else {
      throw NSError(
        domain: "auth", code: 401, userInfo: [NSLocalizedDescriptionKey: "ユーザーが未ログインです"])
    }

    let newImage = NewClothingImage(
      id: UUID(),
      clothing_id: clothingId,
      user_id: user.id,
      original_url: originalUrl,
      mask_url: maskUrl,
      result_url: resultUrl,
      created_at: ISO8601DateFormatter().string(from: Date())
    )

    _ =
      try await client
      .from("clothing_images")
      .insert(newImage)
      .execute()
  }

  func updateImageMaskAndResult(id: UUID, maskUrl: String?, resultUrl: String?) async throws {
    _ =
      try await client
      .from("clothing_images")
      .update([
        "mask_url": maskUrl,
        "result_url": resultUrl,
      ])
      .eq("id", value: id.uuidString)
      .execute()
  }

  func uploadImage(_ image: UIImage, for filename: String) async throws -> String {
    // まずリサイズする（幅を最大800pxに制限）
    let resizedImage = image.resized(toMaxPixel: 800)

    guard let imageData = resizedImage.jpegData(compressionQuality: 0.6) else {
      throw NSError(
        domain: "upload", code: 0, userInfo: [NSLocalizedDescriptionKey: "画像の変換に失敗しました"])
    }

    let path = "\(filename).jpg"

    _ = try await client.storage
      .from(storageBucketName)
      .upload(path, data: imageData, options: FileOptions(contentType: "image/jpeg"))

    guard let urlString = Bundle.main.object(forInfoDictionaryKey: "SUPABASE_URL") as? String else {
      throw NSError(
        domain: "config", code: 0, userInfo: [NSLocalizedDescriptionKey: "Supabase URLが見つかりません"])
    }

    return "\(urlString)/storage/v1/object/public/\(storageBucketName)/\(path)"
  }

  func listClothingImageURLs() async throws -> [URL] {
    guard let userId = currentUser?.id.uuidString else {
      throw NSError(
        domain: "auth", code: 401, userInfo: [NSLocalizedDescriptionKey: "ユーザーが未ログインです"])
    }

    let bucket = client.storage.from(storageBucketName)
    let objects = try await bucket.list(path: userId)

    guard let baseURLString = Bundle.main.object(forInfoDictionaryKey: "SUPABASE_URL") as? String
    else {
      throw NSError(
        domain: "config", code: 0, userInfo: [NSLocalizedDescriptionKey: "Supabase URLが見つかりません"])
    }

    let urls = objects.map { object in
      URL(
        string:
          "\(baseURLString)/storage/v1/object/public/\(storageBucketName)/\(userId)/\(object.name)")
    }

    return urls.compactMap { $0 }
  }

  // MARK: - 服データ

  func fetchClothes() async throws -> [Clothing] {
    return
      try await client
      .from("clothes")
      .select("*")
      .execute()
      .decoded(to: [Clothing].self)
  }

  func addClothing(_ clothing: Clothing) async throws {
    guard let user = currentUser else {
      throw NSError(
        domain: "auth", code: 401, userInfo: [NSLocalizedDescriptionKey: "ユーザーが未ログインです"])
    }
    _ =
      try await client
      .from("clothes")
      .insert([
        "id": clothing.id.uuidString,
        "user_id": user.id.uuidString,
        "name": clothing.name,
        "category": clothing.category,
        "color": clothing.color,
        "created_at": clothing.created_at,
      ])
      .execute()
  }

  func updateClothing(_ clothing: Clothing) async throws {
    _ =
      try await client
      .from("clothes")
      .update([
        "name": clothing.name,
        "category": clothing.category,
        "color": clothing.color,
      ])
      .eq("id", value: clothing.id.uuidString)
      .execute()
  }

  func deleteClothing(_ clothing: Clothing) async throws {
    try await deleteClothingById(clothing.id)
  }

  func deleteClothingById(_ id: UUID) async throws {
    _ =
      try await client
      .from("clothes")
      .delete()
      .eq("id", value: id.uuidString)
      .execute()
  }

  // MARK: - 天気キャッシュ

  func fetchWeatherCache(for city: String) async throws -> Weather {
    let today = DateFormatter.cachedDateFormatter.string(from: Date())

    let response =
      try await client
      .from("weather_cache")
      .select("*")
      .eq("city", value: city)
      .eq("date", value: today)
      .limit(1)
      .execute()

    return try response.decoded(to: Weather.self)
  }

  func insertWeatherCache(_ weather: Weather) async throws {
    _ =
      try await client
      .from("weather_cache")
      .insert(weather)
      .execute()
  }
}

extension DateFormatter {
  static let cachedDateFormatter: DateFormatter = {
    let df = DateFormatter()
    df.dateFormat = "yyyy-MM-dd"
    return df
  }()
}

extension UIImage {
  func resized(toMaxPixel maxPixel: CGFloat) -> UIImage {
    let aspectRatio = size.width / size.height
    var newSize: CGSize
    if aspectRatio > 1 {
      // Landscape
      newSize = CGSize(width: maxPixel, height: maxPixel / aspectRatio)
    } else {
      // Portrait
      newSize = CGSize(width: maxPixel * aspectRatio, height: maxPixel)
    }

    UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
    self.draw(in: CGRect(origin: .zero, size: newSize))
    let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return resizedImage ?? self
  }
}

private struct NewClothingImage: Encodable {
  let id: UUID
  let clothing_id: UUID
  let user_id: UUID
  let original_url: String
  let mask_url: String?
  let result_url: String?
  let created_at: String
}
</file>

<file path="Picklet/Services/WeatherService.swift">
//
//  WeatherService.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

// WeatherService.swift

import CoreLocation
import Foundation
import Supabase

let openWeatherApiKey = "a27cc85d4f34ac0e5e5f4fde84d5067f"

struct OpenWeatherResponse: Codable {
  struct WeatherItem: Codable {
    let description: String
    let icon: String
  }
  struct Main: Codable {
    let temp: Double
  }
  let weather: [WeatherItem]
  let main: Main
}

class WeatherManager {

  static let shared = WeatherManager()

  // キャッシュ取得
  func fetchCachedWeather(for city: String) async throws -> Weather {
    return try await SupabaseService.shared.fetchWeatherCache(for: city)
  }

  // Supabaseに保存
  func saveWeatherToCache(_ weather: Weather) async throws {
    try await SupabaseService.shared.insertWeatherCache(weather)
  }
}
</file>

<file path="Picklet/Utilities/ImagePicker.swift">
//
//  ImagePicker.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import PhotosUI
// Utilities/ImagePicker.swift
import SwiftUI

struct ImagePicker: UIViewControllerRepresentable {
  var onImagePicked: (UIImage) -> Void

  func makeUIViewController(context: Context) -> PHPickerViewController {
    var config = PHPickerConfiguration()
    config.selectionLimit = 1
    config.filter = .images

    let picker = PHPickerViewController(configuration: config)
    picker.delegate = context.coordinator
    return picker
  }

  func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}

  func makeCoordinator() -> Coordinator {
    Coordinator(self)
  }

  class Coordinator: NSObject, PHPickerViewControllerDelegate {
    let parent: ImagePicker

    init(_ parent: ImagePicker) {
      self.parent = parent
    }

    func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
      picker.dismiss(animated: true)

      guard let provider = results.first?.itemProvider else { return }
      if provider.canLoadObject(ofClass: UIImage.self) {
        provider.loadObject(ofClass: UIImage.self) { image, error in
          if let uiImage = image as? UIImage {
            DispatchQueue.main.async {
              self.parent.onImagePicked(uiImage)
            }
          }
        }
      }
    }
  }
}
</file>

<file path="Picklet/ViewModels/ClothingViewModel.swift">
import Foundation
import SwiftUI

@MainActor
class ClothingViewModel: ObservableObject {
  @Published var clothes: [Clothing] = []
  @Published var isLoading = false
  @Published var error: String?

  @Published var imageSetsMap: [UUID: [EditableImageSet]] = [:]

  /// 服を保存（新規 or 更新）
  func updateClothing(_ clothing: Clothing, imageSets: [EditableImageSet], isNew: Bool) async {
    do {
      if isNew {
        try await SupabaseService.shared.addClothing(clothing)
        print("✅ 新規服登録: \(clothing.name)")
      } else {
        try await SupabaseService.shared.updateClothing(clothing)
        print("✅ 服更新: \(clothing.name)")
      }

      for set in imageSets {
        if set.isNew, let original = set.original {
          let originalUrl = try await SupabaseService.shared.uploadImage(
            original, for: UUID().uuidString)
          try await SupabaseService.shared.addImage(for: clothing.id, originalUrl: originalUrl)
          print("✅ 画像アップロード & 登録完了: \(originalUrl)")
        }
      }
    } catch {
      print("❌ 服の保存エラー: \(error.localizedDescription)")
      self.error = error.localizedDescription
    }
  }

  /// すべての服と画像を読み込む（今は画像不要なら削除可）
  func loadClothes() async {
    isLoading = true
    do {
      clothes = try await SupabaseService.shared.fetchClothes()
      print("✅ 服データ読み込み完了: \(clothes.count)件")

      for clothing in clothes {
        let images = try await SupabaseService.shared.fetchImages(for: clothing.id)
        let sets = images.map { img in
          EditableImageSet(
            id: img.id,
            original: nil,
            originalUrl: img.original_url,
            mask: nil,
            maskUrl: nil,
            result: nil,
            resultUrl: nil,
            isNew: false
          )
        }
        imageSetsMap[clothing.id] = sets
      }

      print("✅ 画像データ読み込み完了")
    } catch {
      self.error = error.localizedDescription
    }
    isLoading = false
  }

  /// 服を削除
  func deleteClothing(_ clothing: Clothing) async {
    do {
      try await SupabaseService.shared.deleteClothing(clothing)
      print("🗑️ 削除成功: \(clothing.name)")
      await loadClothes()
    } catch {
      self.error = error.localizedDescription
    }
  }
}
</file>

<file path="Picklet/ViewModels/LibraryPickerViewModel.swift">
//
//  LibraryPickerViewModel.swift
//  MyApp
//
//  Created by al dente on 2025/04/30.
//

import Combine
// ViewModels/LibraryPickerViewModel.swift
import SwiftUI

@MainActor
final class LibraryPickerViewModel: ObservableObject {
  @Published var urls: [URL] = []

  private var cancellables = Set<AnyCancellable>()

  func fetch() {
    Task {
      do {
        self.urls = try await SupabaseService.shared.listClothingImageURLs()
      } catch {
        print("❌ image fetch error:", error)
      }
    }
  }
}
</file>

<file path="Picklet/ViewModels/LoginViewModel.swift">
//
//  LoginViewModel.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

// ViewModels/LoginViewModel.swift
import Foundation

@MainActor
class LoginViewModel: ObservableObject {
  @Published var email = ""
  @Published var password = ""
  @Published var errorMessage: String?
  @Published var isLoading = false
  @Published var isLoggedIn = false

  func login() async {
    do {
      try await SupabaseService.shared.signIn(email: email, password: password)
      errorMessage = nil
    } catch {
      errorMessage = "ログインに失敗しました: \(error.localizedDescription)"
    }
  }

  func signUp() async {
    do {
      try await SupabaseService.shared.signUp(email: email, password: password)
      errorMessage = nil
    } catch {
      errorMessage = "サインアップに失敗しました: \(error.localizedDescription)"
    }
  }
}
</file>

<file path="Picklet/Views/Capture/Camera/CameraPreviewController.swift">
//
//  CameraPreviewController.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import AVFoundation
import UIKit

class CameraPreviewController: UIViewController, AVCapturePhotoCaptureDelegate {
  var captureSession: AVCaptureSession?
  var photoOutput: AVCapturePhotoOutput?
  var previewLayer: AVCaptureVideoPreviewLayer?

  var onImageCaptured: ((UIImage) -> Void)?

  override func viewDidLoad() {
    super.viewDidLoad()
    setupCamera()
  }

  private func setupCamera() {
    captureSession = AVCaptureSession()
    captureSession?.sessionPreset = .high

    guard let backCamera = AVCaptureDevice.default(for: .video),
      let input = try? AVCaptureDeviceInput(device: backCamera),
      let captureSession = captureSession
    else { return }
    if captureSession.canAddInput(input) {
      captureSession.addInput(input)
    }
    photoOutput = AVCapturePhotoOutput()
    if let photoOutput = photoOutput, captureSession.canAddOutput(photoOutput) {
      captureSession.addOutput(photoOutput)
    }
    previewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
    previewLayer?.videoGravity = .resizeAspectFill
    previewLayer?.frame = view.bounds
    if let previewLayer = previewLayer {
      view.layer.addSublayer(previewLayer)
    }
    DispatchQueue.global(qos: .userInitiated).async {
      captureSession.startRunning()
    }
  }

  func capture() {
    let settings = AVCapturePhotoSettings()
    photoOutput?.capturePhoto(with: settings, delegate: self)
  }

  @objc private func capturePhoto() {
    let settings = AVCapturePhotoSettings()
    photoOutput?.capturePhoto(with: settings, delegate: self)
  }

  func photoOutput(
    _ output: AVCapturePhotoOutput,
    didFinishProcessingPhoto photo: AVCapturePhoto,
    error: Error?
  ) {

    guard let data = photo.fileDataRepresentation(),
      let image = UIImage(data: data),
      let layer = previewLayer
    else { return }

    // プレビューに写っていた矩形(0-1正規化) → 画像座標へ変換
    let visible = layer.metadataOutputRectConverted(fromLayerRect: layer.bounds)
    let cg = image.cgImage!
    let crop = CGRect(
      x: visible.origin.x * CGFloat(cg.width),
      y: visible.origin.y * CGFloat(cg.height),
      width: visible.size.width * CGFloat(cg.width),
      height: visible.size.height * CGFloat(cg.height)
    ).integral

    guard let cropped = cg.cropping(to: crop) else {
      onImageCaptured?(image)  // 失敗時はオリジナル
      return
    }

    onImageCaptured?(
      UIImage(
        cgImage: cropped,
        scale: image.scale,
        orientation: image.imageOrientation))
  }

  override func viewDidLayoutSubviews() {
    super.viewDidLayoutSubviews()
    previewLayer?.frame = view.bounds
  }
}
</file>

<file path="Picklet/Views/Capture/Camera/CameraPreviewView.swift">
//
//  CameraPreviewView.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import AVFoundation
import SwiftUI

struct CameraPreviewView: UIViewControllerRepresentable {
  var onImageCaptured: (UIImage) -> Void
  class Coordinator {
    var controller: CameraPreviewController?
  }

  @Binding var triggerCapture: Bool

  func makeCoordinator() -> Coordinator {
    Coordinator()
  }

  func makeUIViewController(context: Context) -> CameraPreviewController {
    let controller = CameraPreviewController()
    controller.onImageCaptured = onImageCaptured
    context.coordinator.controller = controller
    return controller
  }

  func updateUIViewController(_ uiViewController: CameraPreviewController, context: Context) {
    if triggerCapture {
      uiViewController.capture()
      DispatchQueue.main.async {
        triggerCapture = false  // reset after shot
      }
    }
  }
}
</file>

<file path="Picklet/Views/Capture/Camera/CameraSquarePreviewView.swift">
//
//  CameraSquarePreviewView.swift
//  MyApp
//
//  Created by al dente on 2025/04/30.
//

import SwiftUI

struct CameraSquarePreviewView: View {
  let onCaptured: (UIImage) -> Void
  @State private var shouldCapture = false

  var body: some View {
    GeometryReader { geo in
      let size = min(geo.size.width, geo.size.height)

      ZStack {
        CameraPreviewView(onImageCaptured: onCaptured, triggerCapture: $shouldCapture)
          .frame(width: size, height: size)
          .clipped()

        VStack {
          Spacer()
          Button(action: {
            shouldCapture = true
          }) {
            Circle()
              .fill(Color.white)
              .frame(width: 70, height: 70)
              .shadow(radius: 4)
          }
          .padding(.bottom, 40)
        }
      }
    }
  }
}
</file>

<file path="Picklet/Views/Capture/Library/LibraryPickerView.swift">
//
//  LibraryPickerView.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import PhotosUI
import SwiftUI

struct LibraryPickerView: View {
  var onImagePicked: (UIImage) -> Void
  @Environment(\.dismiss) private var dismiss
  @StateObject private var vm = LibraryPickerViewModel()
  @State private var columnsCount: Int = 10
  private let spacing: CGFloat = 4

  var body: some View {
    NavigationView {
      GeometryReader { geo in
        //                let totalSpacing = spacing * CGFloat(columnsCount + 1)
        //                let cellSize = (geo.size.width - totalSpacing) / CGFloat(columnsCount)

        VStack(spacing: spacing) {
          //                    // 列数選択メニュー
          //                    HStack {
          //                        Spacer()
          //                        Menu {
          //                            Button("3列") { columnsCount = 3 }
          //                            Button("4列") { columnsCount = 4 }
          //                            Button("5列") { columnsCount = 5 }
          //                        } label: {
          //                            Label("\(columnsCount)列", systemImage: "square.grid.3x3")
          //                                .padding(.trailing, spacing)
          //                        }
          //                    }

          // グリッド表示
          //                    ScrollView {
          //                        LazyVGrid(
          //                            columns: Array(repeating: .init(.fixed(cellSize), spacing: spacing), count: columnsCount),
          //                            spacing: spacing
          //                        ) {
          //                            ForEach(vm.urls, id: \.self) { url in
          //                                LibraryImageCell(url: url, cellSize: cellSize) { image in
          //                                    onImagePicked(image)
          //                                }
          //                            }
          //                        }
          //                        .padding(spacing)
          //                    }
        }
      }
      .navigationTitle("画像を選択")
      .onAppear { vm.fetch() }
    }
  }
}

// MARK: - セル用サブビュー
struct LibraryImageCell: View {
  let url: URL
  let cellSize: CGFloat
  let onImagePicked: (UIImage) -> Void
  @Environment(\.dismiss) private var dismiss

  var body: some View {
    AsyncImage(url: url, scale: UIScreen.main.scale) { phase in
      switch phase {
      case .success(let image):
        image
          .resizable()
          .interpolation(.high)
          .scaledToFill()
          .frame(width: cellSize, height: cellSize)
          .clipped()
          .cornerRadius(6)
      case .failure:
        Color.gray.opacity(0.2)
          .frame(width: cellSize, height: cellSize)
          .overlay(Image(systemName: "xmark.octagon"))
      default:
        ProgressView()
          .frame(width: cellSize, height: cellSize)
      }
    }
    .onTapGesture {
      Task {
        if let (data, _) = try? await URLSession.shared.data(from: url),
          let uiImage = UIImage(data: data)
        {
          onImagePicked(uiImage)
          dismiss()
        }
      }
    }
  }
}
</file>

<file path="Picklet/Views/Capture/Library/PhotoLibraryPickerView.swift">
//
//  PhotoLibraryPickerView.swift
//  MyApp
//
//  Updated: keep the same item at the top when column count changes
//

import Photos
import SwiftUI

// PreferenceKey to pass each cell's vertical position up the view tree
private struct CellTopPreferenceKey: PreferenceKey {
  static var defaultValue: [String: CGFloat] = [:]
  static func reduce(value: inout [String: CGFloat], nextValue: () -> [String: CGFloat]) {
    value.merge(nextValue(), uniquingKeysWith: { $1 })
  }
}

struct PhotoLibraryPickerView: View {
  let onImagePicked: (UIImage) -> Void
  @Environment(\.dismiss) private var dismiss

  @State private var assets: [PHAsset] = []
  private let imageManager = PHCachingImageManager()

  @State private var columnsCount: Int = 4
  private let spacing: CGFloat = 4

  // id of the cell that was nearest to the top before layout change
  @State private var topVisibleId: String?

  var body: some View {
    NavigationView {
      GeometryReader { geo in
        let totalSpacing = spacing * CGFloat(columnsCount + 1)
        let cellSize = (geo.size.width - totalSpacing) / CGFloat(columnsCount)

        VStack(spacing: spacing) {
          //                    // Column selection buttons
          //                    HStack(spacing: spacing) {
          //                        ForEach([3,4,5,6,7], id: \.self) { count in
          //                            Button("\(count)列") {
          //                                // remember the current top cell id before changing layout
          //                                let currentTop = topVisibleId
          //                                withAnimation {
          //                                    columnsCount = count
          //                                }
          //                                // after slight delay (layout finished) scroll to saved id
          //                                if let id = currentTop {
          //                                    DispatchQueue.main.async {
          //                                        scrollProxy?.scrollTo(id, anchor: .top)
          //                                    }
          //                                }
          //                            }
          //                            .font(.subheadline)
          //                            .padding(.vertical,6)
          //                            .padding(.horizontal,12)
          //                            .background(columnsCount==count ? Color.accentColor.opacity(0.2):Color.clear)
          //                            .cornerRadius(6)
          //                        }
          //                    }
          //                    .padding(.horizontal, spacing)
          //
          //                    Divider()

          // Grid
          ScrollViewReader { proxy in
            ScrollView {
              LazyVGrid(
                columns: Array(
                  repeating: .init(.fixed(cellSize), spacing: spacing), count: columnsCount),
                spacing: spacing
              ) {
                ForEach(assets, id: \.localIdentifier) { asset in
                  PhotoThumbnailCell(asset: asset, size: cellSize, manager: imageManager) { image in
                    onImagePicked(image)
                    dismiss()
                  }
                  .id(asset.localIdentifier)
                  .background(
                    GeometryReader { gp in
                      Color.clear.preference(
                        key: CellTopPreferenceKey.self,
                        value: [asset.localIdentifier: gp.frame(in: .named("gridSpace")).minY])
                    }
                  )
                }
              }
              .padding(spacing)
            }
            .coordinateSpace(name: "gridSpace")
            .onPreferenceChange(CellTopPreferenceKey.self) { values in
              // find the smallest non‑negative Y (closest to top)
              if let (id, _) = values.filter({ $0.value >= 0 }).min(by: { $0.value < $1.value }) {
                topVisibleId = id
              }
            }
            // expose proxy to outer scope via capture list
            .onAppear { scrollProxy = proxy }
          }
        }
        .onAppear(perform: fetchAssets)
      }
      //            .navigationTitle("写真を選択")
    }
  }

  // MARK: - Scroll proxy holder
  @State private var scrollProxy: ScrollViewProxy?

  private func fetchAssets() {
    let opts = PHFetchOptions()
    opts.sortDescriptors = [NSSortDescriptor(key: "creationDate", ascending: false)]
    let result = PHAsset.fetchAssets(with: .image, options: opts)
    var tmp: [PHAsset] = []
    result.enumerateObjects { obj, _, _ in tmp.append(obj) }
    assets = tmp
  }
}

// MARK: - Thumbnail Cell
struct PhotoThumbnailCell: View {
  let asset: PHAsset
  let size: CGFloat
  let manager: PHCachingImageManager
  let onSelect: (UIImage) -> Void

  @State private var thumbnail: UIImage?

  var body: some View {
    ZStack {
      if let thumb = thumbnail {
        Image(uiImage: thumb).resizable().scaledToFill()
      } else {
        Color.gray.opacity(0.2)
      }
    }
    .frame(width: size, height: size)
    .clipped()
    .cornerRadius(6)
    .onAppear(perform: loadThumb)
    .onTapGesture { requestFull() }
  }

  private func loadThumb() {
    let opts = PHImageRequestOptions()
    opts.deliveryMode = .highQualityFormat
    opts.resizeMode = .exact
    let target = CGSize(width: size * UIScreen.main.scale, height: size * UIScreen.main.scale)
    manager.requestImage(for: asset, targetSize: target, contentMode: .aspectFill, options: opts) {
      img, _ in thumbnail = img
    }
  }

  private func requestFull() {
    let opts = PHImageRequestOptions()
    opts.deliveryMode = .highQualityFormat
    opts.resizeMode = .exact
    opts.isNetworkAccessAllowed = true
    let target = CGSize(width: asset.pixelWidth, height: asset.pixelHeight)
    manager.requestImage(for: asset, targetSize: target, contentMode: .aspectFit, options: opts) {
      img, _ in if let img = img { onSelect(img) }
    }
  }
}
</file>

<file path="Picklet/Views/Capture/CaptureOrLibraryView.swift">
//
//  CaptureOrLibraryView.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import SwiftUI

struct CaptureOrLibraryView: View {
  var onImagePicked: (UIImage) -> Void
  var onCancel: (() -> Void)? = nil

  @Environment(\.dismiss) private var dismiss

  @State private var showCamera = true
  @State private var didPickImage = false

  var body: some View {
    VStack(spacing: 0) {
      ZStack {
        if showCamera {
          CameraSquarePreviewView { image in
            didPickImage = true
            onImagePicked(image)
            dismiss()
          }
        } else {
          PhotoLibraryPickerView { image in
            didPickImage = true
            onImagePicked(image)
            dismiss()
          }
        }
      }
      .frame(maxHeight: .infinity)

      ModeSwitchBarView(
        isCameraSelected: showCamera,
        onCamera: { showCamera = true },
        onLibrary: { showCamera = false }
      )
      .ignoresSafeArea()
      .onDisappear {
        if !didPickImage {
          onCancel?()
        }
      }
    }
  }
}
</file>

<file path="Picklet/Views/Capture/ModeSwitchBarView.swift">
//
//  ModeSwitchBarView.swift
//  MyApp
//
//  Created by al dente on 2025/04/30.
//

import SwiftUI

struct ModeSwitchBarView: View {
  let isCameraSelected: Bool
  let onCamera: () -> Void
  let onLibrary: () -> Void

  var body: some View {
    HStack {
      modeButton(icon: "camera", title: "カメラ", isSelected: isCameraSelected, action: onCamera)
      modeButton(
        icon: "photo.on.rectangle", title: "ライブラリ", isSelected: !isCameraSelected, action: onLibrary
      )
    }
    .padding()
    .background(Color(UIColor.systemBackground))
  }

  private func modeButton(
    icon: String, title: String, isSelected: Bool, action: @escaping () -> Void
  ) -> some View {
    Button(action: action) {
      VStack {
        Image(systemName: icon)
          .font(.title)
        //                Text(title)
      }
      .foregroundColor(isSelected ? .blue : .gray)
      .frame(maxWidth: .infinity)
    }
  }
}
</file>

<file path="Picklet/Views/Components/PrimaryActionButton.swift">
//
//  PrimaryActionButton.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

// Views/Components/PrimaryActionButton.swift

import SwiftUI

struct PrimaryActionButton: View {
  let title: String
  let action: () -> Void
  var backgroundColor: Color = Color.gray.opacity(0.2)  // デフォルト薄グレー

  var body: some View {
    Button(action: action) {
      Text(title)
        .font(.headline)
        .foregroundColor(.black)
        .frame(maxWidth: .infinity)
        .frame(height: 50)
        .background(backgroundColor)
        .cornerRadius(12)
        .padding(.horizontal, 24)
        .padding(.vertical, 8)
    }
    .background(Color(UIColor.systemBackground))  // 背景透け防止
  }
}
</file>

<file path="Picklet/Views/Dock/ClothingDockView.swift">
import Combine
import SDWebImageSwiftUI
import SwiftUI

// MARK: - Helper types

/// Wrapper so we can use UUID in sheet/navigationDestination
struct IdentifiableUUID: Identifiable, Hashable { let id: UUID }

/// Exponential‑moving‑average cursor smoother
private struct CursorSmoother {
  private(set) var raw: CGFloat = -1000  // last tapped / dragged target X
  private(set) var ema: CGFloat = -1000  // smoothed X used for UI
  private let alpha: CGFloat = 0.25  // smoothing factor (0‥1)
  mutating func setTarget(_ x: CGFloat) { raw = x }
  mutating func step() { ema += alpha * (raw - ema) }
  var reachedTarget: Bool { abs(raw - ema) < 0.5 }
}

// MARK: - Quick pop‑up view (lightweight card)

struct ClothingQuickView: View {
  let imageURL: String?
  let name: String
  let category: String
  let color: String?

  var body: some View {
    VStack(spacing: 12) {
      if let urlStr = imageURL, let url = URL(string: urlStr) {
        WebImage(url: url, options: [.queryMemoryData, .queryDiskDataSync, .refreshCached]) {
          phase in
          switch phase {
          case .success(let img): img.resizable().scaledToFit()
          case .failure(_):
            Image(systemName: "photo").resizable().scaledToFit().foregroundColor(.secondary)
          default: ProgressView()
          }
        }
        .frame(width: 150, height: 150)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
      }
      Text(name).font(.headline)
      Text(category).font(.subheadline).foregroundColor(.secondary)
      if let c = color {
        Text(c).font(.caption).padding(.horizontal, 8).padding(.vertical, 4)
          .background(Color(.secondarySystemBackground)).cornerRadius(6)
      }
    }
    .padding(24)
  }
}

// MARK: - Single card view

struct ClothingCardView: View {
  @EnvironmentObject private var vm: ClothingViewModel
  @Binding var clothing: Clothing

  let imageURL: String?
  let angle: Angle
  let scale: CGFloat
  let xOffset: CGFloat
  let zIndex: Double
  let onPeek: () -> Void
  let onPopAttempt: () -> Void

  var body: some View {
    ClothingItemView(clothing: clothing, imageUrl: imageURL)
      .environmentObject(vm)
      .frame(width: 120)
      .rotation3DEffect(angle, axis: (0, -1, 0), perspective: 0.7)
      .scaleEffect(scale)
      .offset(x: xOffset)
      .zIndex(zIndex)
      .gesture(
        LongPressGesture(minimumDuration: 0.25, maximumDistance: 20)
          .onEnded { _ in
            UIImpactFeedbackGenerator(style: .heavy).impactOccurred()
            onPeek()
          }
      )
  }
}

// MARK: - Dock View

struct ClothingDockView: View {
  @EnvironmentObject private var vm: ClothingViewModel

  // configuration
  private let maxCards = 20
  private let cardWidth: CGFloat = 120
  private let influence: CGFloat = 160
  private let sideMargin: CGFloat = 0.2

  // cursor smoothing
  @State private var smoother = CursorSmoother()
  @State private var smoothingOn = false

  // Peek & Pop state
  @State private var previewId: IdentifiableUUID? = nil
  @State private var commitId: UUID? = nil

  // timer
  private let tick = Timer.publish(every: 1 / 60, on: .main, in: .common).autoconnect()

  var body: some View {
    GeometryReader { geo in
      ZStack {
        let items = Array(vm.clothes.prefix(maxCards))
        let centreX = geo.size.width / 2

        ForEach(Array(zip(vm.clothes.indices, $vm.clothes)), id: \.1.id) { idx, $clothing in
          let baseX = baseOffsetX(idx: idx, total: items.count, width: geo.size.width)
          let dx = smoother.ema - baseX
          let t = clamp(1 - abs(dx) / influence, 0, 1)
          let angle = Angle(radians: -Double(atan(dx / (cardWidth / 2))))
          let scale = 1 / (2 - t)

          ClothingCardView(
            clothing: $clothing,
            imageURL: vm.imageSetsMap[clothing.id]?.first?.originalUrl,
            angle: angle,
            scale: scale,
            xOffset: baseX - centreX,
            zIndex: Double(t),
            onPeek: { previewId = IdentifiableUUID(id: clothing.id) },
            onPopAttempt: {}
            //                        onPopAttempt: { commitIfFront(id: clothing.id, dx: dx) }
          )
        }
      }
      .frame(maxWidth: .infinity, maxHeight: .infinity)
      // drag
      .contentShape(Rectangle())
      .gesture(
        DragGesture(minimumDistance: 0)
          .onChanged { v in setCursor(to: v.location.x) }
      )
      // smoother tick
      .onReceive(tick) { _ in stepSmoother() }
      // overlay (peek)
      .overlay { overlayQuickView() }
      // pop navigation
      .navigationDestination(item: $commitId) { id in
        if let binding = bindingFor(id: id) {
          ClothingDetailView(clothing: binding, clothingId: id)
            .environmentObject(vm)
        }
      }
      .task {  // initial centre
        if smoother.raw < 0 { setCursor(to: geo.size.width / 2) }
      }
    }
  }

  // MARK: – Cursor helpers
  private func setCursor(to x: CGFloat) {
    smoother.setTarget(x)
    smoothingOn = true
  }
  private func stepSmoother() {
    guard smoothingOn else { return }
    smoother.step()
    if smoother.reachedTarget { smoothingOn = false }
  }

  // MARK: – Peek / Pop helpers
  private func overlayQuickView() -> some View {
    Group {
      if let wrap = previewId,
        let cloth = vm.clothes.first(where: { $0.id == wrap.id })
      {
        ZStack {
          Color.black.opacity(0.5).ignoresSafeArea()
            .onTapGesture { previewId = nil }
          ClothingQuickView(
            imageURL: vm.imageSetsMap[cloth.id]?.first?.originalUrl,
            name: cloth.name,
            category: cloth.category,
            color: cloth.color
          )
          .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 20))
          .shadow(radius: 10)
          .transition(.scale.combined(with: .opacity))
          .onTapGesture {
            commitId = cloth.id
            previewId = nil
          }
        }
        .zIndex(20)
        .animation(.spring(), value: previewId)
      }
    }
  }

  // MARK: – Utilities
  private func baseOffsetX(idx: Int, total: Int, width: CGFloat) -> CGFloat {
    let usable = width * (1 - 2 * sideMargin)
    return width * sideMargin + usable * CGFloat(idx) / CGFloat(max(total - 1, 1))
  }

  private func bindingFor(id: UUID) -> Binding<Clothing>? {
    guard let i = vm.clothes.firstIndex(where: { $0.id == id }) else { return nil }
    return $vm.clothes[i]
  }

  private func clamp<T: Comparable>(_ v: T, _ lo: T, _ hi: T) -> T { min(max(v, lo), hi) }
}
</file>

<file path="Picklet/Views/Edit/Image/ImageEditView.swift">
//
//  ImageEditView.swift
//  MyApp
//
//  Created by al dente on 2025/04/29.
//

// ImageEditView.swift
import SwiftUI

struct CropingMessageView: View {
  var body: some View {
    Color.black.opacity(0.4)  // 🔲 全体を暗くする
      .ignoresSafeArea()

    VStack {
      ProgressView("AIが画像を切り抜いています")
        .padding()
        .background(.ultraThinMaterial)
        .cornerRadius(12)
        .foregroundColor(.primary)
    }
    .padding()
    .transition(.opacity)
  }
}

struct ImageEditView: View {
  @Binding var imageSet: EditableImageSet?

  @State private var maskedImage: UIImage?
  @State private var isCropping = true

  var body: some View {
    ZStack {
      VStack {
        if let set = imageSet {
          if isCropping {
            ImageView(image: set.original, urlStr: set.originalUrl)
          } else {
            ImageView(image: set.mask, urlStr: set.maskUrl)
          }
        } else {
          Text("画像が見つかりません")
        }
      }
      .padding()
      .task {
        await processImageSet()
      }
      if isCropping {
        CropingMessageView()
      }
    }
  }

  private func processImageSet() async {
    if let output = await CoreMLService.shared.processImageSet(imageSet: imageSet) {
      imageSet = output
      isCropping = false
    }
  }
}
</file>

<file path="Picklet/Views/Edit/Image/ImageView.swift">
//
//  ImageView.swift
//  MyApp
//
//  Created by al dente on 2025/05/01.
//

import SDWebImageSwiftUI
import SwiftUI

struct DecoratedImage: View {
  let image: Image
  let size: CGFloat

  var body: some View {
    image
      .resizable()
      .aspectRatio(1, contentMode: .fill)
      .frame(width: size, height: size)
      .clipped()
      .cornerRadius(12)
      .shadow(radius: 4)
  }
}

struct ImageView: View {
  let image: UIImage?
  let urlStr: String?

  var body: some View {
    if let image = image {
      DecoratedImage(image: Image(uiImage: image), size: 300)
    } else if let urlStr = urlStr, let url = URL(string: urlStr) {
      WebImage(url: url, options: [.queryMemoryData, .queryDiskDataSync, .refreshCached]) { phase in
        switch phase {
        case .empty:
          ProgressView()
        case .success(let image):
          DecoratedImage(image: image, size: 300)
        case .failure:
          Text("画像読み込み失敗")
        @unknown default:
          EmptyView()
        }
      }
    } else {
      Text("画像なし")
    }
  }
}
</file>

<file path="Picklet/Views/Edit/ClothingEditView.swift">
import SDWebImageSwiftUI
import SwiftUI

struct ClothingEditView: View {
  @EnvironmentObject var viewModel: ClothingViewModel
  @Environment(\.dismiss) var dismiss
  @Binding var clothing: Clothing

  let openPhotoPickerOnAppear: Bool
  let canDelete: Bool
  let isNew: Bool

  @State private var showPhotoPicker = false
  @State private var showImageEditView = false
  @State private var showDeleteConfirm = false

  @State private var imageSets: [EditableImageSet] = []
  @State private var selectedImageSet: EditableImageSet? = nil

  var body: some View {
    VStack {
      Form {
        ScrollView(.horizontal, showsIndicators: false) {
          HStack {
            ForEach(imageSets) { imageSet in
              imageButton(for: imageSet)
            }
            Button(action: {
              showPhotoPicker = true
            }) {
              VStack {
                Image(systemName: "plus")
                  .font(.largeTitle)
                  .frame(width: 150, height: 150)
                  .background(Color.gray.opacity(0.2))
                  .cornerRadius(8)
              }
            }
          }
          .padding(.vertical)
        }
        Section(header: Text("服の情報")) {
          TextField("名前", text: $clothing.name)
          TextField("カテゴリ", text: $clothing.category)
          TextField("色", text: $clothing.color)
        }

        if canDelete {
          Section {
            Button(role: .destructive) {
              showDeleteConfirm = true
            } label: {
              Text("この服を削除する")
                .foregroundColor(.red)
                .frame(maxWidth: .infinity, alignment: .center)
            }
          }
        }
      }

      PrimaryActionButton(title: "変更を保存") {
        Task {
          await saveChanges()
          dismiss()
        }
      }
      .padding()
    }
    .navigationTitle("服を編集")
    .sheet(isPresented: $showPhotoPicker) {
      CaptureOrLibraryView { selectedImage in
        let newSet = EditableImageSet(
          id: UUID(),
          original: selectedImage.normalized(),
          originalUrl: nil,
          mask: nil,
          maskUrl: nil,
          result: nil,
          resultUrl: nil,
          isNew: true
        )
        imageSets.append(newSet)
      }
    }
    .confirmationDialog("本当に削除しますか？", isPresented: $showDeleteConfirm) {
      Button("削除する", role: .destructive) {
        Task {
          await viewModel.deleteClothing(clothing)
          dismiss()
        }
      }
      Button("キャンセル", role: .cancel) {}
    }
    .task {
      await loadImages()
    }
    .onAppear {
      if openPhotoPickerOnAppear {
        showPhotoPicker = true
      }
    }
    .sheet(isPresented: $showImageEditView) {
      ImageEditView(imageSet: $selectedImageSet)
    }
  }

  private func loadImages() async {
    do {
      let fetchedImages = try await SupabaseService.shared.fetchImages(for: clothing.id)
      imageSets = fetchedImages.map { clothingImage in
        EditableImageSet(
          id: clothingImage.id,
          original: nil,
          originalUrl: clothingImage.original_url,
          mask: nil,
          maskUrl: nil,
          result: nil,
          resultUrl: nil,
          isNew: false
        )
      }
    } catch {
      print("❌ 画像取得エラー: \(error.localizedDescription)")
    }
  }

  private func saveChanges() async {
    do {
      if isNew {
        try await SupabaseService.shared.addClothing(clothing)
      } else {
        try await SupabaseService.shared.updateClothing(clothing)
      }

      for set in imageSets {
        if set.isNew, let original = set.original {
          let originalUrl = try await SupabaseService.shared.uploadImage(
            original, for: UUID().uuidString)
          try await SupabaseService.shared.addImage(for: clothing.id, originalUrl: originalUrl)
          print("✅ 画像保存完了: \(originalUrl)")
        }
      }
    } catch {
      print("❌ 保存エラー: \(error.localizedDescription)")
    }
  }

  private func imageButton(for imageSet: EditableImageSet) -> some View {
    Button {
      selectedImageSet = imageSet
      showImageEditView = true
    } label: {
      Group {
        if let original = imageSet.original {
          Image(uiImage: original)
            .resizable()
        } else if let urlString = imageSet.originalUrl, let url = URL(string: urlString) {
          WebImage(url: url)
            .resizable()
            .indicator(.activity)
        } else {
          Color.gray
        }
      }
      .scaledToFill()
      .frame(width: 150, height: 150)
      .clipped()
      .cornerRadius(8)
    }
  }
}
</file>

<file path="Picklet/Views/ClothingCropEditView.swift">
//
//  ClothingCropEditView.swift
//  MyApp
//
//  Created by al dente on 2025/04/26.
//

import SwiftUI

struct ClothingCropEditView: View {
  let originalImage: UIImage
  let onComplete: (UIImage) -> Void

  @State private var userMaskImage = UIImage()
  @State private var currentPenColor = UIColor.white

  @Environment(\.dismiss) private var dismiss

  @State private var maskedImage: UIImage?
  @State private var isLoading = true

  @StateObject private var canvasCoordinator = MaskEditCanvasView.Coordinator()

  var body: some View {
    VStack {
      if isLoading {
        ProgressView("AIが服を切り抜いています…")
          .padding()
      } else if let result = maskedImage {
        ZStack {
          Image(uiImage: result)
            .resizable()
            .scaledToFit()
            .padding()

          MaskEditCanvasView(drawingImage: $userMaskImage, penColor: currentPenColor, penWidth: 20)
            .frame(width: 300, height: 400)
            .background(Color.clear)
            .environmentObject(canvasCoordinator)
        }

        Button("登録する") {
          let exportedMask = canvasCoordinator.exportDrawingImage()
          onComplete(exportedMask)
          dismiss()
        }
        .padding()
      } else {
        Text("切り抜きに失敗しました")
        Button("戻る") {
          dismiss()
        }
        .padding()
      }
    }
    .navigationTitle("画像編集")
    .navigationBarTitleDisplayMode(.inline)
    .task {
      await processImage()
    }
  }

  private func processImage() async {
    if let output = await CoreMLService.shared.processImage(image: originalImage) {
      self.maskedImage = output
    }
    self.isLoading = false
  }
}
</file>

<file path="Picklet/Views/ClothingCropPreviewView.swift">
////
////  ClothingCropPreviewView.swift
////  MyApp
////
////  Created by al dente on 2025/04/26.
////
//
//import SwiftUI
//
//struct ClothingCropPreviewView: View {
//    @Environment(\.dismiss) private var dismiss
//    let originalImage: UIImage
//    var onConfirm: (UIImage) -> Void
//    var onRetry: () -> Void
//
//    @State private var maskedImage: UIImage?
//    @State private var maskVisualizationImage: UIImage?
//    @State private var progress: Double = 0.0
//    @State private var isAnimating = false
//
//    @State private var isLoading = true
//    @State private var timer: Timer?
//
//    var body: some View {
//        VStack {
//            if isLoading {
//                VStack(spacing: 16) {
//                    ProgressView("AIが服を切り抜いています…")
//                    Text("お使いのiPhone上でAIが動作中です")
//                        .font(.caption)
//                        .foregroundColor(.gray)
//                }
//                .padding()
//            } else {
//                if let masked = maskedImage, let maskVisual = maskVisualizationImage {
//                    ZStack {
//                        Image(uiImage: masked)
//                            .resizable()
//                            .scaledToFit()
//                            .opacity(1.0 - progress)
//
//                        Image(uiImage: maskVisual)
//                            .resizable()
//                            .scaledToFit()
//                            .opacity(progress)
//                    }
//                    .animation(.easeInOut(duration: 1.5), value: progress)
//                    .padding()
//
//                    HStack {
//                        Button("やり直す") {
//                            stopAnimation()
//                            onRetry()
//                        }
//                        .padding()
//
//                        Button("この画像で登録") {
//                            stopAnimation()
//                            onConfirm(masked)
//                            dismiss()
//                        }
//                        .padding()
//                    }
//                } else {
//                    Text("切り抜きに失敗しました")
//                    Button("やり直す") {
//                        stopAnimation()
//                        onRetry()
//                    }
//                }
//            }
//        }
//        .onAppear {
//            print("🛠 CropPreviewView appeared！originalImageあり")
//
//            Task {
//                print("🛠 CoreML processImage開始")
//
//                let inputImage = originalImage.fixedOrientation()
//
//                if let final = await CoreMLService.shared.processImage(image: inputImage),
//                   let maskOnly = CoreMLService.shared.predictMask(for: inputImage) {
//
//                    self.maskedImage = final
//                    self.maskVisualizationImage = ImageProcessor.visualizeMaskOnOriginal(original: inputImage, mask: maskOnly)
//
//                    print("🛠 maskedImageとmaskVisualizationImageセット完了！")
//
//                    startAnimation()
//                } else {
//                    print("❌ maskedImage作成失敗")
//                }
//
//                self.isLoading = false
//            }
//        }
//        .onDisappear {
//            stopAnimation()
//        }
//    }
//
//    // ⭐️ アニメーションスタート
//    private func startAnimation() {
//        timer = Timer.scheduledTimer(withTimeInterval: 1.5, repeats: true) { _ in
//            withAnimation(.easeInOut(duration: 1.5)) {
//                self.progress = (self.progress == 1.0) ? 0.0 : 1.0
//            }
//        }
//    }
//
//    // ⭐️ アニメーションストップ
//    private func stopAnimation() {
//        timer?.invalidate()
//        timer = nil
//    }
//}
</file>

<file path="Picklet/Views/ClothingDetailView.swift">
import SDWebImageSwiftUI
import SwiftUI

struct ClothingDetailView: View {
  @EnvironmentObject var viewModel: ClothingViewModel
  @Environment(\.dismiss) private var dismiss

  @Binding var clothing: Clothing
  let clothingId: UUID

  @State private var showEdit = false
  @State private var images: [ClothingImage] = []

  var body: some View {
    VStack {
      ScrollView(.horizontal, showsIndicators: false) {
        HStack {
          ForEach(images) { image in
            if let url = URL(string: image.original_url) {
              WebImage(url: url, options: [.queryMemoryData, .queryDiskDataSync, .refreshCached])
                .resizable()
                .indicator(.activity)
                .transition(.fade(duration: 0.5))
                .scaledToFill()
                .frame(width: 150, height: 150)
                .clipped()
                .cornerRadius(8)
            } else {
              Rectangle()
                .fill(Color.gray.opacity(0.2))
                .frame(width: 150, height: 150)
                .cornerRadius(8)
            }
          }
        }
        .padding()
      }

      Text(clothing.name)
        .font(.title)

      Spacer()
    }
    .navigationTitle("服の詳細")
    .safeAreaInset(edge: .bottom) {
      PrimaryActionButton(title: "編集する") {
        showEdit = true
      }
    }
    .sheet(isPresented: $showEdit) {
      ClothingEditView(
        clothing: $clothing,
        openPhotoPickerOnAppear: false,
        canDelete: true,
        isNew: false
      )
      .environmentObject(viewModel)
    }
    .onChange(of: viewModel.clothes) { oldClothes, newClothes in
      if !newClothes.contains(where: { $0.id == clothingId }) {
        dismiss()
      }
    }
    .task {
      await loadImages()
    }
  }

  private func loadImages() async {
    do {
      images = try await SupabaseService.shared.fetchImages(for: clothing.id)
    } catch {
      print("❌ 画像取得エラー: \(error.localizedDescription)")
    }
  }
}
</file>

<file path="Picklet/Views/ClothingItemView.swift">
import SDWebImageSwiftUI
import SwiftUI

struct ClothingItemView: View {
  let clothing: Clothing
  let imageUrl: String?

  var body: some View {
    VStack {
      if let urlString = imageUrl, let url = URL(string: urlString) {
        WebImage(url: url, options: [.queryMemoryData, .queryDiskDataSync, .refreshCached])
          .resizable()
          .indicator(.activity)
          .transition(.fade(duration: 0.5))
          .scaledToFill()
          .frame(width: 100, height: 100)
          .clipped()
          .cornerRadius(8)
      } else {
        placeholderView
      }
    }
    .frame(width: 100)
    .padding()
    .background(Color(.secondarySystemBackground))
    .cornerRadius(12)
    .shadow(radius: 2)
  }

  private var placeholderView: some View {
    Rectangle()
      .fill(Color.gray.opacity(0.2))
      .frame(width: 100, height: 100)
      .cornerRadius(8)
  }
}
</file>

<file path="Picklet/Views/ClothingListView.swift">
import SwiftUI

// PreferenceKey to capture each item's vertical offset in the scroll view
private struct TopItemPreferenceKey: PreferenceKey {
  static var defaultValue: [UUID: CGFloat] = [:]
  static func reduce(value: inout [UUID: CGFloat], nextValue: () -> [UUID: CGFloat]) {
    value.merge(nextValue(), uniquingKeysWith: { $1 })
  }
}

struct ClothingListView: View {
  @StateObject private var viewModel = ClothingViewModel()

  // grid columns can be changed by the user (2–4) – default 2
  @State private var columnCount: Int = 2

  // id of the item that is currently top‑most (captured via PreferenceKey)
  @State private var topVisibleId: UUID?

  // scroll proxy saved once to reuse when columnCount changes
  @State private var scrollProxy: ScrollViewProxy?

  @State private var navigateToEdit = false
  @State private var editingClothing: Clothing?
  @State private var isNewClothing = false

  // spacing between cells
  private let spacing: CGFloat = 16

  @State private var useDockView = true

  var body: some View {
    NavigationStack {
      ClothingDockView().environmentObject(viewModel)
        //            VStack(spacing: 0) {
        //                // column selector
        //                HStack(spacing: 12) {
        //                    ForEach(2...4, id: \ .self) { n in
        //                        Button("\(n)") {
        //                            // remember current top before changing layout
        //                            let currentTop = topVisibleId
        //                            withAnimation { columnCount = n }
        //                            // after layout change, scroll back to the same item
        //                            if let id = currentTop {
        //                                DispatchQueue.main.async {
        //                                    scrollProxy?.scrollTo(id, anchor: .top)
        //                                }
        //                            }
        //                        }
        //                        .padding(6)
        //                        .background(columnCount == n ? Color.accentColor.opacity(0.2) : Color.clear)
        //                        .cornerRadius(6)
        //                    }
        //                }
        //                .font(.subheadline)
        //                .padding([.horizontal,.top])
        //
        //                ScrollViewReader { proxy in
        //                    ScrollView {
        //                        LazyVGrid(columns: Array(repeating: .init(.flexible(), spacing: spacing), count: columnCount), spacing: spacing) {
        //                            ForEach($viewModel.clothes, id: \ .id) { $clothing in
        //                                NavigationLink(destination: ClothingDetailView(clothing: $clothing, clothingId: clothing.id).environmentObject(viewModel)) {
        //                                    ClothingItemView(clothing: clothing, imageUrl: viewModel.imageSetsMap[clothing.id]?.first?.originalUrl)
        //                                        .environmentObject(viewModel)
        //                                }
        //                                .id(clothing.id) // enable scrollTo
        //                                .background(
        //                                    GeometryReader { geo in
        //                                        Color.clear.preference(key: TopItemPreferenceKey.self, value: [clothing.id: geo.frame(in: .named("gridSpace")).minY])
        //                                    }
        //                                )
        //                            }
        //                        }
        //                        .padding(spacing)
        //                    }
        //                    .coordinateSpace(name: "gridSpace")
        //                    .onPreferenceChange(TopItemPreferenceKey.self) { values in
        //                        if let (id, _) = values.filter({ $0.value >= 0 }).min(by: { $0.value < $1.value }) {
        //                            topVisibleId = id
        //                        }
        //                    }
        //                    .onAppear { scrollProxy = proxy }
        //                }
        //            }
        .navigationTitle("My Clothes")
        .safeAreaInset(edge: .bottom) {
          PrimaryActionButton(title: "写真から服を追加") {
            if let user = SupabaseService.shared.currentUser {
              let newClothing = Clothing(
                id: UUID(), user_id: user.id, name: "", category: "", color: "",
                created_at: ISO8601DateFormatter().string(from: Date()), updated_at: "")
              self.editingClothing = newClothing
              self.isNewClothing = true
              self.navigateToEdit = true
            }
          }
        }
        .navigationDestination(isPresented: $navigateToEdit) {
          if let editingClothing = editingClothing {
            ClothingEditView(
              clothing: Binding(get: { editingClothing }, set: { self.editingClothing = $0 }),
              openPhotoPickerOnAppear: true, canDelete: false, isNew: true
            )
            .environmentObject(viewModel)
          }
        }
        .task { await viewModel.loadClothes() }
    }
  }
}
</file>

<file path="Picklet/Views/EditableImageSet.swift">
//
//  EditableImageSet.swift
//  MyApp
//
//  Created by al dente on 2025/04/29.
//

import SwiftUI

struct EditableImageSet: Identifiable {
  let id: UUID
  var original: UIImage?
  var originalUrl: String?
  var mask: UIImage?
  var maskUrl: String?
  var result: UIImage?
  var resultUrl: String?
  var isNew: Bool
}

extension EditableImageSet {
  init(original: UIImage) {
    self.id = UUID()
    self.original = original
    self.originalUrl = nil
    self.mask = nil
    self.maskUrl = nil
    self.result = nil
    self.resultUrl = nil
    self.isNew = true
  }
}
</file>

<file path="Picklet/Views/LocationTestView.swift">
//
//  LocationTestView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import SwiftUI

struct LocationTestView: View {
  @StateObject private var locationManager = LocationManager()

  var body: some View {
    VStack {
      if let placemark = locationManager.placemark {
        Text("都道府県: \(placemark.administrativeArea ?? "不明")")
        Text("市区町村: \(placemark.locality ?? "不明")")
      } else if let error = locationManager.locationError {
        Text("エラー: \(error.localizedDescription)")
      } else {
        Text("位置情報を取得中...")
      }
    }
    .padding()
  }
}
</file>

<file path="Picklet/Views/LoginView.swift">
//
//  LoginView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

// Views/LoginView.swift
import SwiftUI

struct LoginView: View {
  @StateObject private var viewModel = LoginViewModel()

  var body: some View {
    VStack(spacing: 16) {
      Text("ログイン")
        .font(.largeTitle)
        .bold()

      TextField("メールアドレス", text: $viewModel.email)
        .autocapitalization(.none)
        .textFieldStyle(RoundedBorderTextFieldStyle())
        .keyboardType(.emailAddress)

      SecureField("パスワード", text: $viewModel.password)
        .textFieldStyle(RoundedBorderTextFieldStyle())

      if let error = viewModel.errorMessage {
        Text(error)
          .foregroundColor(.red)
          .font(.caption)
      }

      if viewModel.isLoading {
        ProgressView()
      }

      Button("ログイン") {
        Task {
          await viewModel.login()
        }
      }

      Button("新規登録") {
        Task { await viewModel.signUp() }
      }
    }
    .padding()
  }
}
</file>

<file path="Picklet/Views/MainTabView.swift">
//
//  MainTabView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import SwiftUI

struct MainTabView: View {
  var body: some View {
    TabView {
      ClothingListView()
        .tabItem {
          //                    Label("クローゼット", systemImage: "tshirt")
          Image(systemName: "tshirt")

        }

      //            WeatherLoaderView()
      //                .tabItem {
      //                    Label("今日のコーデ", systemImage: "sun.max")
      //                }

      SettingsView()
        .tabItem {
          //                    Label("設定", systemImage: "gear")
          Image(systemName: "gear")
        }
    }
  }
}
</file>

<file path="Picklet/Views/MaskEditCanvasView.swift">
//
//  MaskEditCanvasView.swift
//  MyApp
//
//  Created by al dente on 2025/04/28.
//

import SwiftUI

struct MaskEditCanvasView: UIViewRepresentable {
  @Binding var drawingImage: UIImage
  var penColor: UIColor
  var penWidth: CGFloat = 20.0

  func makeCoordinator() -> Coordinator {
    Coordinator()
  }

  func makeUIView(context: Context) -> DrawingCanvas {
    let canvas = DrawingCanvas()
    context.coordinator.canvas = canvas
    canvas.isUserInteractionEnabled = true
    return canvas
  }

  func updateUIView(_ uiView: DrawingCanvas, context: Context) {
    uiView.penColor = penColor
    uiView.penWidth = penWidth
  }

  class Coordinator: ObservableObject {
    var canvas: DrawingCanvas?

    func exportDrawingImage() -> UIImage {
      return canvas?.exportDrawingImage() ?? UIImage()
    }
  }

  class DrawingCanvas: UIView {
    private var lines: [Line] = []
    var penColor: UIColor = .white
    var penWidth: CGFloat = 20.0
    private var lastPoint: CGPoint?

    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
      if let point = touches.first?.location(in: self) {
        lastPoint = point
      }
    }

    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
      guard let point = touches.first?.location(in: self), let last = lastPoint else { return }
      lines.append(Line(from: last, to: point, color: penColor, width: penWidth))
      lastPoint = point
      setNeedsDisplay()
    }

    override func draw(_ rect: CGRect) {
      guard let context = UIGraphicsGetCurrentContext() else { return }
      for line in lines {
        context.setStrokeColor(line.color.cgColor)
        context.setLineWidth(line.width)
        context.setLineCap(.round)
        context.move(to: line.from)
        context.addLine(to: line.to)
        context.strokePath()
      }
    }

    func exportDrawingImage() -> UIImage {
      UIGraphicsBeginImageContextWithOptions(bounds.size, false, 0)
      drawHierarchy(in: bounds, afterScreenUpdates: true)
      let image = UIGraphicsGetImageFromCurrentImageContext()
      UIGraphicsEndImageContext()
      return image ?? UIImage()
    }
  }

  struct Line {
    let from: CGPoint
    let to: CGPoint
    let color: UIColor
    let width: CGFloat
  }
}
</file>

<file path="Picklet/Views/SettingsView.swift">
//
//  SettingsView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import SwiftUI

struct SettingsView: View {
  @Environment(\.dismiss) var dismiss
  @AppStorage("autoCropEnabled") private var autoCropEnabled: Bool = true

  var body: some View {
    NavigationView {
      Form {
        Section(header: Text("切り抜き設定")) {
          Toggle("自動で切り抜く", isOn: $autoCropEnabled)
        }

        Section {
          Button("ログアウト", role: .destructive) {
            Task {
              try? await SupabaseService.shared.signOut()
              dismiss()
            }
          }
        }
      }
      .navigationTitle("設定")
    }
  }
}
</file>

<file path="Picklet/Views/WeatherLoaderView.swift">
//
//  WeatherLoaderView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import SwiftUI

struct WeatherLoaderView: View {
  @StateObject private var locationManager = LocationManager()
  @State private var weather: Weather?
  @State private var isLoading = true
  @State private var errorMessage: String?

  var body: some View {
    Group {
      if isLoading {
        ProgressView("天気情報を取得中...")
      } else if let weather = weather {
        WeatherView(weather: weather)
      } else if let errorMessage = errorMessage {
        Text(errorMessage)
          .foregroundColor(.red)
          .padding()
      }
    }
    .onChange(of: locationManager.placemark) {
      guard weather == nil && errorMessage == nil else { return }
      Task {
        await loadWeather()
      }
    }

  }

  private func loadWeather() async {
    print("🌀 loadWeather called")
    guard let placemark = locationManager.placemark else {
      errorMessage = "位置情報が取得できませんでした"
      isLoading = false
      return
    }

    // 県や市の表示確認
    let prefecture = placemark.administrativeArea ?? "不明"
    let city = placemark.locality ?? placemark.subAdministrativeArea ?? "不明"

    print("🗾 現在地: \(prefecture) / \(city)")

    if city == "不明" {
      errorMessage = "位置情報から市区町村を取得できませんでした"
      isLoading = false
      return
    }

    do {
      let fetchedWeather = try await WeatherManager.shared.fetchCachedWeather(for: city)
      self.weather = fetchedWeather
    } catch {
      self.errorMessage = "天気情報の取得に失敗しました: \(error.localizedDescription)"
      print("❌ 天気取得失敗: \(error)")
    }

    isLoading = false
  }

}
</file>

<file path="Picklet/Views/WeatherView.swift">
//
//  WeatherView.swift
//  MyApp
//
//  Created by al dente on 2025/04/25.
//

import SwiftUI

struct WeatherView: View {
  let weather: Weather

  var body: some View {
    VStack(spacing: 8) {
      if let url = URL(string: "https://openweathermap.org/img/wn/\(weather.icon)@2x.png") {
        AsyncImage(url: url) { image in
          image
            .resizable()
            .scaledToFit()
            .frame(width: 100, height: 100)
        } placeholder: {
          ProgressView()
        }
      }
      Text(weather.condition)
        .font(.headline)
      Text("\(weather.temperature, specifier: "%.1f")℃")
        .font(.title)
        .bold()
    }
    .padding()
  }
}
</file>

<file path="Picklet/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDocumentTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeName</key>
			<string></string>
			<key>LSHandlerRank</key>
			<string>Default</string>
		</dict>
	</array>
	<key>CFBundleURLTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLName</key>
			<string></string>
			<key>CFBundleURLSchemes</key>
			<array/>
		</dict>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLName</key>
			<string></string>
		</dict>
	</array>
	<key>SUPABASE_KEY</key>
	<string>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZsbXdsdmthaXpncmNxenlvbmZ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU1MDM0NzAsImV4cCI6MjA2MTA3OTQ3MH0.EymP7N-yMrCHVkBpzEG3sfBWckHjYxYkv9_DvOU6KCI</string>
	<key>SUPABASE_URL</key>
	<string>https://vlmwlvkaizgrcqzyonfy.supabase.co</string>
</dict>
</plist>
</file>

<file path="Picklet/PickletApp.swift">
//
//  MyAppApp.swift
//  MyApp
//
//  Created by al dente on 2025/04/12.
//

import SwiftUI

@main
struct PickletApp: App {
  @AppStorage("isLoggedIn") var isLoggedIn = false

  var body: some Scene {
    WindowGroup {
      if isLoggedIn && SupabaseService.shared.currentUser != nil {
        MainTabView()
      } else {
        LoginView()
      }
    }
  }
}
</file>

<file path="Picklet.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved">
{
  "originHash" : "15a4f8b25dc920ea2b643a29110bc3885ebd0af1cf374488f67945c07339a683",
  "pins" : [
    {
      "identity" : "sdwebimage",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/SDWebImage/SDWebImage.git",
      "state" : {
        "revision" : "cac9a55a3ae92478a2c95042dcc8d9695d2129ca",
        "version" : "5.21.0"
      }
    },
    {
      "identity" : "sdwebimageswiftui",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/SDWebImage/SDWebImageSwiftUI",
      "state" : {
        "revision" : "451c6dfd5ecec2cf626d1d9ca81c2d4a60355172",
        "version" : "3.1.3"
      }
    },
    {
      "identity" : "supabase-swift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/supabase/supabase-swift",
      "state" : {
        "revision" : "4c4f2a0483a794e9294ae0f550a63881e4ee1de9",
        "version" : "2.26.1"
      }
    },
    {
      "identity" : "swift-asn1",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-asn1.git",
      "state" : {
        "revision" : "a54383ada6cecde007d374f58f864e29370ba5c3",
        "version" : "1.3.2"
      }
    },
    {
      "identity" : "swift-clocks",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pointfreeco/swift-clocks",
      "state" : {
        "revision" : "cc46202b53476d64e824e0b6612da09d84ffde8e",
        "version" : "1.0.6"
      }
    },
    {
      "identity" : "swift-concurrency-extras",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pointfreeco/swift-concurrency-extras",
      "state" : {
        "revision" : "82a4ae7170d98d8538ec77238b7eb8e7199ef2e8",
        "version" : "1.3.1"
      }
    },
    {
      "identity" : "swift-crypto",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-crypto.git",
      "state" : {
        "revision" : "e8d6eba1fef23ae5b359c46b03f7d94be2f41fed",
        "version" : "3.12.3"
      }
    },
    {
      "identity" : "swift-http-types",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-http-types.git",
      "state" : {
        "revision" : "a0a57e949a8903563aba4615869310c0ebf14c03",
        "version" : "1.4.0"
      }
    },
    {
      "identity" : "xctest-dynamic-overlay",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pointfreeco/xctest-dynamic-overlay",
      "state" : {
        "revision" : "39de59b2d47f7ef3ca88a039dff3084688fe27f4",
        "version" : "1.5.2"
      }
    }
  ],
  "version" : 3
}
</file>

<file path="Picklet.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict/>
</plist>
</file>

<file path="Picklet.xcodeproj/project.xcworkspace/xcuserdata/reiji.xcuserdatad/Bookmarks/bookmarks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>top-level-items</key>
	<array>
		<dict>
			<key>destination</key>
			<dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>MyApp.xcodeproj</string>
					</dict>
				</dict>
				<key>type</key>
				<string>DVTDocumentLocation</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
	</array>
</dict>
</plist>
</file>

<file path="Picklet.xcodeproj/project.xcworkspace/xcuserdata/reiji.xcuserdatad/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>BuildLocationStyle</key>
	<string>UseAppPreferences</string>
	<key>CustomBuildLocationType</key>
	<string>RelativeToDerivedData</string>
	<key>DerivedDataLocationStyle</key>
	<string>Default</string>
	<key>ShowSharedSchemesAutomaticallyEnabled</key>
	<true/>
</dict>
</plist>
</file>

<file path="Picklet.xcodeproj/project.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
</file>

<file path="Picklet.xcodeproj/xcshareddata/xcschemes/MyApp.xcscheme">
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1620"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "B57C87D52DAA27A0001C2153"
               BuildableName = "Picklet.app"
               BlueprintName = "Picklet"
               ReferencedContainer = "container:Picklet.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "B57C87E52DAA27A1001C2153"
               BuildableName = "PickletTests.xctest"
               BlueprintName = "PickletTests"
               ReferencedContainer = "container:Picklet.xcodeproj">
            </BuildableReference>
         </TestableReference>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "B57C87EF2DAA27A1001C2153"
               BuildableName = "PickletUITests.xctest"
               BlueprintName = "PickletUITests"
               ReferencedContainer = "container:Picklet.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "B57C87D52DAA27A0001C2153"
            BuildableName = "Picklet.app"
            BlueprintName = "Picklet"
            ReferencedContainer = "container:Picklet.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "B57C87D52DAA27A0001C2153"
            BuildableName = "Picklet.app"
            BlueprintName = "Picklet"
            ReferencedContainer = "container:Picklet.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
</file>

<file path="Picklet.xcodeproj/xcuserdata/reiji.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist">
<?xml version="1.0" encoding="UTF-8"?>
<Bucket
   uuid = "9B6B3E3A-824B-482C-84F1-70FB2ADE8217"
   type = "1"
   version = "2.0">
</Bucket>
</file>

<file path="Picklet.xcodeproj/xcuserdata/reiji.xcuserdatad/xcschemes/xcschememanagement.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>MyApp.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
	<key>SuppressBuildableAutocreation</key>
	<dict>
		<key>B57C87D52DAA27A0001C2153</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>B57C87E52DAA27A1001C2153</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>B57C87EF2DAA27A1001C2153</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
	</dict>
</dict>
</plist>
</file>

<file path="Picklet.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXBuildFile section */
		B53EF51A2DBA8C8B00F5CA39 /* Auth in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF5192DBA8C8B00F5CA39 /* Auth */; };
		B53EF51C2DBA8C8B00F5CA39 /* Functions in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF51B2DBA8C8B00F5CA39 /* Functions */; };
		B53EF51E2DBA8C8B00F5CA39 /* PostgREST in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF51D2DBA8C8B00F5CA39 /* PostgREST */; };
		B53EF5202DBA8C8B00F5CA39 /* Realtime in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF51F2DBA8C8B00F5CA39 /* Realtime */; };
		B53EF5222DBA8C8B00F5CA39 /* Storage in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF5212DBA8C8B00F5CA39 /* Storage */; };
		B53EF5242DBA8C8B00F5CA39 /* Supabase in Frameworks */ = {isa = PBXBuildFile; productRef = B53EF5232DBA8C8B00F5CA39 /* Supabase */; };
		B57CB8AD2DBB457300789BEF /* SDWebImageSwiftUI in Frameworks */ = {isa = PBXBuildFile; productRef = B57CB8AC2DBB457300789BEF /* SDWebImageSwiftUI */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		B57C87E72DAA27A1001C2153 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = B57C87CE2DAA27A0001C2153 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = B57C87D52DAA27A0001C2153;
			remoteInfo = MyApp;
		};
		B57C87F12DAA27A1001C2153 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = B57C87CE2DAA27A0001C2153 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = B57C87D52DAA27A0001C2153;
			remoteInfo = MyApp;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXFileReference section */
		B57C87D62DAA27A0001C2153 /* Picklet.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Picklet.app; sourceTree = BUILT_PRODUCTS_DIR; };
		B57C87E62DAA27A1001C2153 /* PickletTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = PickletTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		B57C87F02DAA27A1001C2153 /* PickletUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = PickletUITests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedBuildFileExceptionSet section */
		B53EF5382DBAA65500F5CA39 /* Exceptions for "Picklet" folder in "Picklet" target */ = {
			isa = PBXFileSystemSynchronizedBuildFileExceptionSet;
			membershipExceptions = (
				Info.plist,
			);
			target = B57C87D52DAA27A0001C2153 /* Picklet */;
		};
/* End PBXFileSystemSynchronizedBuildFileExceptionSet section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		B57C87D82DAA27A0001C2153 /* Picklet */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			exceptions = (
				B53EF5382DBAA65500F5CA39 /* Exceptions for "Picklet" folder in "Picklet" target */,
			);
			path = Picklet;
			sourceTree = "<group>";
		};
		B57C87E92DAA27A1001C2153 /* PickletTests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = PickletTests;
			sourceTree = "<group>";
		};
		B57C87F32DAA27A1001C2153 /* PickletUITests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = PickletUITests;
			sourceTree = "<group>";
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		B57C87D32DAA27A0001C2153 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				B57CB8AD2DBB457300789BEF /* SDWebImageSwiftUI in Frameworks */,
				B53EF51E2DBA8C8B00F5CA39 /* PostgREST in Frameworks */,
				B53EF51C2DBA8C8B00F5CA39 /* Functions in Frameworks */,
				B53EF5242DBA8C8B00F5CA39 /* Supabase in Frameworks */,
				B53EF51A2DBA8C8B00F5CA39 /* Auth in Frameworks */,
				B53EF5222DBA8C8B00F5CA39 /* Storage in Frameworks */,
				B53EF5202DBA8C8B00F5CA39 /* Realtime in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87E32DAA27A1001C2153 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87ED2DAA27A1001C2153 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		B53EF5182DBA8C8B00F5CA39 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		B57C87CD2DAA27A0001C2153 = {
			isa = PBXGroup;
			children = (
				B57C87D82DAA27A0001C2153 /* Picklet */,
				B57C87E92DAA27A1001C2153 /* PickletTests */,
				B57C87F32DAA27A1001C2153 /* PickletUITests */,
				B53EF5182DBA8C8B00F5CA39 /* Frameworks */,
				B57C87D72DAA27A0001C2153 /* Products */,
			);
			sourceTree = "<group>";
		};
		B57C87D72DAA27A0001C2153 /* Products */ = {
			isa = PBXGroup;
			children = (
				B57C87D62DAA27A0001C2153 /* Picklet.app */,
				B57C87E62DAA27A1001C2153 /* PickletTests.xctest */,
				B57C87F02DAA27A1001C2153 /* PickletUITests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		B57C87D52DAA27A0001C2153 /* Picklet */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = B57C87FA2DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "Picklet" */;
			buildPhases = (
				B57C87D22DAA27A0001C2153 /* Sources */,
				B57C87D32DAA27A0001C2153 /* Frameworks */,
				B57C87D42DAA27A0001C2153 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				B57C87D82DAA27A0001C2153 /* Picklet */,
			);
			name = Picklet;
			packageProductDependencies = (
				B53EF5192DBA8C8B00F5CA39 /* Auth */,
				B53EF51B2DBA8C8B00F5CA39 /* Functions */,
				B53EF51D2DBA8C8B00F5CA39 /* PostgREST */,
				B53EF51F2DBA8C8B00F5CA39 /* Realtime */,
				B53EF5212DBA8C8B00F5CA39 /* Storage */,
				B53EF5232DBA8C8B00F5CA39 /* Supabase */,
				B57CB8AC2DBB457300789BEF /* SDWebImageSwiftUI */,
			);
			productName = MyApp;
			productReference = B57C87D62DAA27A0001C2153 /* Picklet.app */;
			productType = "com.apple.product-type.application";
		};
		B57C87E52DAA27A1001C2153 /* PickletTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = B57C87FD2DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "PickletTests" */;
			buildPhases = (
				B57C87E22DAA27A1001C2153 /* Sources */,
				B57C87E32DAA27A1001C2153 /* Frameworks */,
				B57C87E42DAA27A1001C2153 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				B57C87E82DAA27A1001C2153 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				B57C87E92DAA27A1001C2153 /* PickletTests */,
			);
			name = PickletTests;
			packageProductDependencies = (
			);
			productName = MyAppTests;
			productReference = B57C87E62DAA27A1001C2153 /* PickletTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		B57C87EF2DAA27A1001C2153 /* PickletUITests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = B57C88002DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "PickletUITests" */;
			buildPhases = (
				B57C87EC2DAA27A1001C2153 /* Sources */,
				B57C87ED2DAA27A1001C2153 /* Frameworks */,
				B57C87EE2DAA27A1001C2153 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				B57C87F22DAA27A1001C2153 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				B57C87F32DAA27A1001C2153 /* PickletUITests */,
			);
			name = PickletUITests;
			packageProductDependencies = (
			);
			productName = MyAppUITests;
			productReference = B57C87F02DAA27A1001C2153 /* PickletUITests.xctest */;
			productType = "com.apple.product-type.bundle.ui-testing";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		B57C87CE2DAA27A0001C2153 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1620;
				LastUpgradeCheck = 1620;
				TargetAttributes = {
					B57C87D52DAA27A0001C2153 = {
						CreatedOnToolsVersion = 16.2;
					};
					B57C87E52DAA27A1001C2153 = {
						CreatedOnToolsVersion = 16.2;
						TestTargetID = B57C87D52DAA27A0001C2153;
					};
					B57C87EF2DAA27A1001C2153 = {
						CreatedOnToolsVersion = 16.2;
						TestTargetID = B57C87D52DAA27A0001C2153;
					};
				};
			};
			buildConfigurationList = B57C87D12DAA27A0001C2153 /* Build configuration list for PBXProject "Picklet" */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = B57C87CD2DAA27A0001C2153;
			minimizedProjectReferenceProxies = 1;
			packageReferences = (
				B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */,
				B53EF53B2DBB3F6700F5CA39 /* XCRemoteSwiftPackageReference "SDWebImageSwiftUI" */,
			);
			preferredProjectObjectVersion = 77;
			productRefGroup = B57C87D72DAA27A0001C2153 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				B57C87D52DAA27A0001C2153 /* Picklet */,
				B57C87E52DAA27A1001C2153 /* PickletTests */,
				B57C87EF2DAA27A1001C2153 /* PickletUITests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		B57C87D42DAA27A0001C2153 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87E42DAA27A1001C2153 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87EE2DAA27A1001C2153 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		B57C87D22DAA27A0001C2153 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87E22DAA27A1001C2153 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		B57C87EC2DAA27A1001C2153 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		B57C87E82DAA27A1001C2153 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = B57C87D52DAA27A0001C2153 /* Picklet */;
			targetProxy = B57C87E72DAA27A1001C2153 /* PBXContainerItemProxy */;
		};
		B57C87F22DAA27A1001C2153 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = B57C87D52DAA27A0001C2153 /* Picklet */;
			targetProxy = B57C87F12DAA27A1001C2153 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin XCBuildConfiguration section */
		B57C87F82DAA27A1001C2153 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		B57C87F92DAA27A1001C2153 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		B57C87FB2DAA27A1001C2153 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"Picklet/Preview Content\"";
				DEVELOPMENT_TEAM = 8WZMDG8UJ5;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = Picklet/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = Picklet;
				INFOPLIST_KEY_LSSupportsOpeningDocumentsInPlace = YES;
				INFOPLIST_KEY_NSCameraUsageDescription = "カメラで撮影するためにカメラへのアクセスを許可してください。";
				INFOPLIST_KEY_NSLocationWhenInUseUsageDescription = "天気情報を取得するために位置情報を使用します";
				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "写真を選択するためにフォトライブラリへのアクセスを許可してください。";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = UIInterfaceOrientationPortrait;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.Picklet;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		B57C87FC2DAA27A1001C2153 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"Picklet/Preview Content\"";
				DEVELOPMENT_TEAM = 8WZMDG8UJ5;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = Picklet/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = Picklet;
				INFOPLIST_KEY_LSSupportsOpeningDocumentsInPlace = YES;
				INFOPLIST_KEY_NSCameraUsageDescription = "カメラで撮影するためにカメラへのアクセスを許可してください。";
				INFOPLIST_KEY_NSLocationWhenInUseUsageDescription = "天気情報を取得するために位置情報を使用します";
				INFOPLIST_KEY_NSPhotoLibraryUsageDescription = "写真を選択するためにフォトライブラリへのアクセスを許可してください。";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = UIInterfaceOrientationPortrait;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.Picklet;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
		B57C87FE2DAA27A1001C2153 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 8WZMDG8UJ5;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.PickletTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Picklet.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Picklet";
			};
			name = Debug;
		};
		B57C87FF2DAA27A1001C2153 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 8WZMDG8UJ5;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.PickletTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Picklet.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Picklet";
			};
			name = Release;
		};
		B57C88012DAA27A1001C2153 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.PickletUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_TARGET_NAME = Picklet;
			};
			name = Debug;
		};
		B57C88022DAA27A1001C2153 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = Reiji.PickletUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_TARGET_NAME = Picklet;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		B57C87D12DAA27A0001C2153 /* Build configuration list for PBXProject "Picklet" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				B57C87F82DAA27A1001C2153 /* Debug */,
				B57C87F92DAA27A1001C2153 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		B57C87FA2DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "Picklet" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				B57C87FB2DAA27A1001C2153 /* Debug */,
				B57C87FC2DAA27A1001C2153 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		B57C87FD2DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "PickletTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				B57C87FE2DAA27A1001C2153 /* Debug */,
				B57C87FF2DAA27A1001C2153 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		B57C88002DAA27A1001C2153 /* Build configuration list for PBXNativeTarget "PickletUITests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				B57C88012DAA27A1001C2153 /* Debug */,
				B57C88022DAA27A1001C2153 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */

/* Begin XCRemoteSwiftPackageReference section */
		B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/supabase/supabase-swift";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 2.5.1;
			};
		};
		B53EF53B2DBB3F6700F5CA39 /* XCRemoteSwiftPackageReference "SDWebImageSwiftUI" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/SDWebImage/SDWebImageSwiftUI";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 3.1.3;
			};
		};
/* End XCRemoteSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		B53EF5192DBA8C8B00F5CA39 /* Auth */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = Auth;
		};
		B53EF51B2DBA8C8B00F5CA39 /* Functions */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = Functions;
		};
		B53EF51D2DBA8C8B00F5CA39 /* PostgREST */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = PostgREST;
		};
		B53EF51F2DBA8C8B00F5CA39 /* Realtime */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = Realtime;
		};
		B53EF5212DBA8C8B00F5CA39 /* Storage */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = Storage;
		};
		B53EF5232DBA8C8B00F5CA39 /* Supabase */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF5172DBA8AD700F5CA39 /* XCRemoteSwiftPackageReference "supabase-swift" */;
			productName = Supabase;
		};
		B57CB8AC2DBB457300789BEF /* SDWebImageSwiftUI */ = {
			isa = XCSwiftPackageProductDependency;
			package = B53EF53B2DBB3F6700F5CA39 /* XCRemoteSwiftPackageReference "SDWebImageSwiftUI" */;
			productName = SDWebImageSwiftUI;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = B57C87CE2DAA27A0001C2153 /* Project object */;
}
</file>

<file path="PickletTests/PickletTests.swift">
//
//  MyAppTests.swift
//  MyAppTests
//
//  Created by al dente on 2025/04/12.
//

import Testing

@testable import MyApp

struct PickletTests {

  @Test func example() async throws {
    // Write your test here and use APIs like `#expect(...)` to check expected conditions.
  }

  @Test func testLogin() async throws {
    let viewModel = LoginViewModel()
    viewModel.email = "test@example.com"
    viewModel.password = "password123"

    await viewModel.login()

    XCTAssertTrue(viewModel.isLoggedIn)
    XCTAssertNil(viewModel.errorMessage)
  }

}
</file>

<file path="PickletUITests/PickletUITests.swift">
//
//  MyAppUITests.swift
//  MyAppUITests
//
//  Created by al dente on 2025/04/12.
//

import XCTest

final class PickletUITests: XCTestCase {

  override func setUpWithError() throws {
    // Put setup code here. This method is called before the invocation of each test method in the class.

    // In UI tests it is usually best to stop immediately when a failure occurs.
    continueAfterFailure = false

    // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
  }

  override func tearDownWithError() throws {
    // Put teardown code here. This method is called after the invocation of each test method in the class.
  }

  @MainActor
  func testExample() throws {
    // UI tests must launch the application that they test.
    let app = XCUIApplication()
    app.launch()

    // Use XCTAssert and related functions to verify your tests produce the correct results.
  }

  @MainActor
  func testLaunchPerformance() throws {
    if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *) {
      // This measures how long it takes to launch your application.
      measure(metrics: [XCTApplicationLaunchMetric()]) {
        XCUIApplication().launch()
      }
    }
  }
}
</file>

<file path="PickletUITests/PickletUITestsLaunchTests.swift">
//
//  MyAppUITestsLaunchTests.swift
//  MyAppUITests
//
//  Created by al dente on 2025/04/12.
//

import XCTest

final class PickletUITestsLaunchTests: XCTestCase {

  override class var runsForEachTargetApplicationUIConfiguration: Bool {
    true
  }

  override func setUpWithError() throws {
    continueAfterFailure = false
  }

  @MainActor
  func testLaunch() throws {
    let app = XCUIApplication()
    app.launch()

    // Insert steps here to perform after app launch but before taking a screenshot,
    // such as logging into a test account or navigating somewhere in the app

    let attachment = XCTAttachment(screenshot: app.screenshot())
    attachment.name = "Launch Screen"
    attachment.lifetime = .keepAlways
    add(attachment)
  }
}
</file>

<file path=".gitattributes">
*.mlmodel filter=lfs diff=lfs merge=lfs -text
</file>

<file path=".gitignore">
.DS_Store
</file>

<file path=".swiftlint.yml">
disabled_rules:
  - trailing_whitespace
  - line_length
  - force_cast

opt_in_rules:
  - force_unwrapping
  - empty_count
</file>

<file path="run_app.sh">
#!/bin/bash

# 設定項目（あなたの環境に合わせて変更）
SCHEME="MyApp"  # ← Xcodeのスキーム名
BUNDLE_ID="com.example.MyApp"  # ← あなたのアプリのバンドルID
DEVICE_UDID="926C9EF3-F840-444D-8361-6B802B550C23"

echo "🔄 シミュレータを起動中: iPhone 16 ($DEVICE_UDID)"
xcrun simctl boot "$DEVICE_UDID" || echo "🟡 既に起動済みかもしれません"

# ビルド
echo "🛠 アプリをビルド中..."
xcodebuild -scheme "$SCHEME" -destination "id=$DEVICE_UDID" build || {
    echo "❌ ビルド失敗"
    exit 1
}

# .app の場所を自動で探す（最も最近のビルド）
APP_PATH=$(find ~/Library/Developer/Xcode/DerivedData -type d -name "$SCHEME.app" | sort -r | head -n 1)

if [ -z "$APP_PATH" ]; then
    echo "❌ .app が見つかりません"
    exit 1
fi

# インストールと起動
echo "📲 アプリをシミュレータにインストール: $APP_PATH"
xcrun simctl install "$DEVICE_UDID" "$APP_PATH"

echo "🚀 アプリを起動: $BUNDLE_ID"
xcrun simctl launch "$DEVICE_UDID" "$BUNDLE_ID"
</file>

<file path="run_device.sh">
#!/bin/bash

# === 必須設定 ===============================
SCHEME="MyApp"                      # あなたのXcodeのスキーム名に変更
BUNDLE_ID="com.example.MyApp"       # あなたのアプリのバンドルIDに変更
DEVICE_UDID="00008101-000968C90E28001E" # あなたのiPhoneのUDIDに差し替え
# ============================================

echo "🔧 実機ビルド＆インストール開始（UDID: $DEVICE_UDID）"

# ビルド＆署名（プロビジョニングプロファイル自動対応）
xcodebuild -scheme "$SCHEME" \
  -destination "platform=iOS,id=$DEVICE_UDID" \
  -allowProvisioningUpdates \
  build || {
    echo "❌ ビルドに失敗しました"
    exit 1
}

# .app の検索（最新のビルド成果物）
APP_PATH=$(find ~/Library/Developer/Xcode/DerivedData -name "$SCHEME.app" | sort -r | head -n 1)

if [ -z "$APP_PATH" ]; then
    echo "❌ .app が見つかりません"
    exit 1
fi

echo "📲 インストール中: $APP_PATH"
xcrun simctl install "$DEVICE_UDID" "$APP_PATH" || {
    echo "❌ インストールに失敗しました"
    exit 1
}

echo "🚀 起動中: $BUNDLE_ID"
xcrun simctl launch "$DEVICE_UDID" "$BUNDLE_ID" || {
    echo "❌ 起動に失敗しました"
    exit 1
}
</file>

</files>
