import Foundation
import Supabase
import UIKit

// We need to properly import the helper files within the Xcode project structure
// without adding module qualifiers since they're part of the same module

/// Service for clothing image metadata (database operations)
/// Handles synchronization between local storage and remote database
final class ImageMetadataService {
  static let shared = ImageMetadataService()
  private let client: SupabaseClient
  private let localStorageService = LocalStorageService.shared
  private let updater: ImageMetadataUpdater

  private init(client: SupabaseClient = AuthService.shared.client) {
    self.client = client
    updater = ImageMetadataUpdater(client: client)
  }

  private var currentUser: User? {
    AuthService.shared.currentUser
  }

  /// „Ç™„Éï„É©„Ç§„É≥„Éï„Ç°„Éº„Çπ„Éà„Ç¢„Éó„É≠„Éº„ÉÅ„ÅßÁîªÂÉè„É°„Çø„Éá„Éº„Çø„ÇíÂèñÂæó
  /// 1. „Åæ„Åö„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâÂèñÂæó
  /// 2. „Çµ„Éº„Éê„Éº„Åã„ÇâÂèñÂæó„Åó„Å¶Êõ¥Êñ∞
  /// - Parameter clothingId: Êúç„ÅÆID
  /// - Returns: ÁîªÂÉè„É°„Çø„Éá„Éº„Çø„ÅÆÈÖçÂàó
  func fetchImages(for clothingId: UUID) async throws -> [ClothingImage] {
    // „Åæ„Åö„É≠„Éº„Ç´„É´„Åã„Çâ„Éá„Éº„Çø„ÇíÂèñÂæó
    let localImages = localStorageService.loadImageMetadata(for: clothingId)

    do {
      // „Çµ„Éº„Éê„Éº„Åã„Çâ„ÅÆ„Éá„Éº„ÇøÂèñÂæó„ÇíË©¶„Åø„Çã
      let serverImages = try await fetchImagesFromServer(for: clothingId)

      // „Çµ„Éº„Éê„Éº„Åã„Çâ„ÅÆ„Éá„Éº„Çø„Å®„É≠„Éº„Ç´„É´„Éá„Éº„Çø„Çí„Éû„Éº„Ç∏
      let updatedImages = await syncImagesWithLocalStorage(
        serverImages: serverImages,
        clothingId: clothingId,
        localImages: localImages)

      return updatedImages
    } catch {
      print("üåê „Çµ„Éº„Éê„Éº„Åã„Çâ„ÅÆ„Éá„Éº„ÇøÂèñÂæó„Å´Â§±Êïó„ÄÅ„É≠„Éº„Ç´„É´„Éá„Éº„Çø„Çí‰ΩøÁî®: \(error.localizedDescription)")
      if localImages.isEmpty {
        throw error // „É≠„Éº„Ç´„É´„Éá„Éº„Çø„ÇÇÁÑ°„Åë„Çå„Å∞„Ç®„É©„Éº„ÇíÊäï„Åí„Çã
      }
      return localImages
    }
  }

  /// „Çµ„Éº„Éê„Éº„Åã„ÇâÁîªÂÉè„É°„Çø„Éá„Éº„Çø„ÇíÂèñÂæó
  /// - Parameter clothingId: Êúç„ÅÆID
  /// - Returns: ÁîªÂÉè„É°„Çø„Éá„Éº„Çø„ÅÆÈÖçÂàó
  private func fetchImagesFromServer(for clothingId: UUID) async throws -> [ClothingImage] {
    let response = try await client
      .from("clothing_images")
      .select("*")
      .eq("clothing_id", value: clothingId.uuidString)
      .execute()
    return try response.decoded(to: [ClothingImage].self)
  }

  /// „Çµ„Éº„Éê„Éº„Å®„É≠„Éº„Ç´„É´„ÅÆÁîªÂÉè„Éá„Éº„Çø„ÇíÂêåÊúü
  /// - Parameters:
  ///   - serverImages: „Çµ„Éº„Éê„Éº„Åã„ÇâÂèñÂæó„Åó„ÅüÁîªÂÉè„É°„Çø„Éá„Éº„Çø
  ///   - clothingId: Êúç„ÅÆID
  ///   - localImages: „É≠„Éº„Ç´„É´„ÅÆÁîªÂÉè„É°„Çø„Éá„Éº„Çø
  /// - Returns: Êõ¥Êñ∞„Åï„Çå„ÅüÁîªÂÉè„É°„Çø„Éá„Éº„Çø
  private func syncImagesWithLocalStorage(
    serverImages: [ClothingImage],
    clothingId: UUID,
    localImages: [ClothingImage]) async -> [ClothingImage] {
    var updatedImages = [ClothingImage]()

    for serverImage in serverImages {
      if let localImage = localImages.first(where: { $0.id == serverImage.id }) {
        // Êó¢Â≠ò„ÅÆÁîªÂÉè„ÇíÊõ¥Êñ∞
        let updatedImage = await updateExistingImage(serverImage: serverImage, localImage: localImage)
        updatedImages.append(updatedImage)
      } else {
        // Êñ∞„Åó„ÅÑÁîªÂÉè„ÇíËøΩÂä†
        let newImage = await downloadNewImage(serverImage: serverImage)
        updatedImages.append(newImage)
      }
    }

    // Êõ¥Êñ∞„Åï„Çå„ÅüÁîªÂÉè„É°„Çø„Éá„Éº„Çø„Çí„É≠„Éº„Ç´„É´„Å´‰øùÂ≠ò
    localStorageService.saveImageMetadata(for: clothingId, imageMetadata: updatedImages)

    return updatedImages
  }

  /// Êó¢Â≠ò„ÅÆ„É≠„Éº„Ç´„É´ÁîªÂÉè„ÇíÊõ¥Êñ∞
  private func updateExistingImage(serverImage: ClothingImage, localImage: ClothingImage) async -> ClothingImage {
    // „É≠„Éº„Ç´„É´„Éë„Çπ„Çí‰øùÊåÅ„Åó„Åü„Çµ„Éº„Éê„Éº„Ç§„É°„Éº„Ç∏„ÅÆÊñ∞„Åó„ÅÑ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê
    let updatedImage = ClothingImage(
      id: serverImage.id,
      clothingId: serverImage.clothingId,
      userId: serverImage.userId,
      originalUrl: serverImage.originalUrl,
      maskUrl: serverImage.maskUrl,
      aimaskUrl: serverImage.aimaskUrl,
      resultUrl: serverImage.resultUrl,
      originalLocalPath: localImage.originalLocalPath,
      maskLocalPath: localImage.maskLocalPath,
      resultLocalPath: localImage.resultLocalPath,
      createdAt: serverImage.createdAt,
      updatedAt: serverImage.updatedAt)

    // ÂøÖË¶Å„Å´Âøú„Åò„Å¶ÂêÑÁîªÂÉè„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
    let finalImage = await downloadMissingImages(for: updatedImage)
    return finalImage
  }

  /// ÁîªÂÉè„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„Å´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Å¶Êõ¥Êñ∞
  private func downloadMissingImages(for image: ClothingImage) async -> ClothingImage {
    var finalImage = image

    // „Ç™„É™„Ç∏„Éä„É´ÁîªÂÉè„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
    if finalImage.originalLocalPath == nil,
       let urlString = finalImage.originalUrl,
       let url = URL(string: urlString) {
      if let localPath = await downloadImage(from: url, id: finalImage.id, type: "original") {
        finalImage = finalImage.updatingLocalPath(originalLocalPath: localPath)
      }
    }

    // „Éû„Çπ„ÇØÁîªÂÉè„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
    if finalImage.maskLocalPath == nil,
       let urlString = finalImage.maskUrl,
       let url = URL(string: urlString) {
      if let localPath = await downloadImage(from: url, id: finalImage.id, type: "mask") {
        finalImage = finalImage.updatingLocalPath(maskLocalPath: localPath)
      }
    }

    // ÁµêÊûúÁîªÂÉè„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
    if finalImage.resultLocalPath == nil,
       let urlString = finalImage.resultUrl,
       let url = URL(string: urlString) {
      if let localPath = await downloadImage(from: url, id: finalImage.id, type: "result") {
        finalImage = finalImage.updatingLocalPath(resultLocalPath: localPath)
      }
    }

    return finalImage
  }

  /// Êñ∞„Åó„ÅÑÁîªÂÉè„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Å¶ËøΩÂä†
  private func downloadNewImage(serverImage: ClothingImage) async -> ClothingImage {
    var originalLocalPath: String?
    var maskLocalPath: String?
    var resultLocalPath: String?

    // ÂêÑURL„Åã„Çâ„Éï„Ç°„Ç§„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
    if let urlString = serverImage.originalUrl, let url = URL(string: urlString) {
      originalLocalPath = await downloadImage(from: url, id: serverImage.id, type: "original")
    }

    if let urlString = serverImage.maskUrl, let url = URL(string: urlString) {
      maskLocalPath = await downloadImage(from: url, id: serverImage.id, type: "mask")
    }

    if let urlString = serverImage.resultUrl, let url = URL(string: urlString) {
      resultLocalPath = await downloadImage(from: url, id: serverImage.id, type: "result")
    }

    // Êñ∞„Åó„ÅÑ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê„Åó„Å¶„É≠„Éº„Ç´„É´„Éë„Çπ„ÇíË®≠ÂÆö
    return ClothingImage(
      id: serverImage.id,
      clothingId: serverImage.clothingId,
      userId: serverImage.userId,
      originalUrl: serverImage.originalUrl,
      maskUrl: serverImage.maskUrl,
      aimaskUrl: serverImage.aimaskUrl,
      resultUrl: serverImage.resultUrl,
      originalLocalPath: originalLocalPath,
      maskLocalPath: maskLocalPath,
      resultLocalPath: resultLocalPath,
      createdAt: serverImage.createdAt,
      updatedAt: serverImage.updatedAt)
  }

  /// URL„Åã„ÇâÁîªÂÉè„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Å¶„É≠„Éº„Ç´„É´„Å´‰øùÂ≠ò
  private func downloadImage(from url: URL, id: UUID, type: String) async -> String? {
    return await withCheckedContinuation { continuation in
      localStorageService.downloadAndSaveImage(from: url, id: id, type: type) { localPath, _ in
        continuation.resume(returning: localPath)
      }
    }
  }

  /// Add a new image metadata record
  func addImage(
    for clothingId: UUID,
    originalUrl: String,
    aimaskUrl: String? = nil,
    maskUrl: String? = nil,
    resultUrl: String? = nil) async throws {
    guard let user = currentUser else {
      throw NSError(
        domain: "auth", code: 401,
        userInfo: [NSLocalizedDescriptionKey: "„É¶„Éº„Ç∂„Éº„ÅåÊú™„É≠„Ç∞„Ç§„É≥„Åß„Åô"])
    }

    let imageId = UUID()
    let newImage = NewClothingImage(
      id: imageId,
      clothingID: clothingId,
      userID: user.id,
      originalURL: originalUrl,
      aimaskURL: aimaskUrl,
      maskURL: maskUrl,
      resultURL: resultUrl,
      createdAt: ISO8601DateFormatter().string(from: Date()))

    // „Çµ„Éº„Éê„Éº„Å´ÁîªÂÉè„É°„Çø„Éá„Éº„Çø„Çí‰øùÂ≠ò
    _ = try await client
      .from("clothing_images")
      .insert(newImage)
      .execute()

    // „É≠„Éº„Ç´„É´„Å´„ÇÇÁîªÂÉè„É°„Çø„Éá„Éº„Çø„Çí‰øùÂ≠ò
    let newClothingImage = ClothingImage(
      id: imageId,
      clothingId: clothingId,
      userId: String(describing: user.id),  // Explicitly convert user.id to String
      originalUrl: originalUrl,
      maskUrl: maskUrl,
      aimaskUrl: aimaskUrl,
      resultUrl: resultUrl,
      createdAt: Date(),
      updatedAt: Date())

    var localImages = localStorageService.loadImageMetadata(for: clothingId)
    localImages.append(newClothingImage)
    localStorageService.saveImageMetadata(for: clothingId, imageMetadata: localImages)

    // URL„Åã„ÇâÁîªÂÉè„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
    if let url = URL(string: originalUrl) {
      _ = await downloadImage(from: url, id: imageId, type: "original")
    }
  }

  /// Update the mask URL for an existing image record
  func updateImageMask(imageId: UUID, maskUrl: String) async throws {
    try await updater.updateImageMask(imageId: imageId, maskUrl: maskUrl)
  }

  /// Update the result URL for an existing image record
  func updateImageResult(imageId: UUID, resultUrl: String) async throws {
    try await updater.updateImageResult(imageId: imageId, resultUrl: resultUrl)
  }

  /// Update both mask and result URLs for an existing image record
  func updateImageMaskAndResult(
    imageId: UUID,
    maskUrl: String?,
    resultUrl: String?) async throws {
    try await updater.updateImageMaskAndResult(
      imageId: imageId,
      maskUrl: maskUrl,
      resultUrl: resultUrl)
  }

  /// Update the AI mask URL for an existing image record
  func updateImageAIMask(imageId: UUID, aimaskUrl: String) async throws {
    try await updater.updateImageAIMask(imageId: imageId, aimaskUrl: aimaskUrl)
  }

  /// Function to get image from an existing record
  func getImage(imageId: UUID) async throws -> ClothingImage? {
    // „Çµ„Éº„Éê„Éº‰∏ä„ÅÆ„Éá„Éº„Çø„ÇíÊ§úÁ¥¢
    do {
      // Âçò‰∏Ä„ÅÆÁîªÂÉè„ÇíÂèñÂæó„Åô„Çã„ÇØ„Ç®„É™„ÇíÂÆüË°å
      let response = try await client
        .from("clothing_images")
        .select("*")
        .eq("id", value: imageId.uuidString)
        .execute()

      // „É¨„Çπ„Éù„É≥„Çπ„Çí„Éá„Ç≥„Éº„Éâ
      let images = try response.decoded(to: [ClothingImage].self)

      // ÁîªÂÉè„ÅåË¶ã„Å§„Åã„Å£„ÅüÂ†¥Âêà
      guard let image = images.first else {
        // Ë¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØnil„ÇíËøî„Åô
        return nil
      }

      // clothingId„ÅØÊó¢„Å´non-optionalÂûã„Å™„ÅÆ„Åß„ÄÅÂº∑Âà∂„Ç¢„É≥„É©„ÉÉ„Éó„ÅØ‰∏çË¶Å
      let clothingId = image.clothingId

      // „Çµ„Éº„Éê„Éº„Åã„ÇâÈñ¢ÈÄ£„Åô„ÇãÂÖ®„Å¶„ÅÆÁîªÂÉè„ÇíÂèñÂæó
      do {
        let allImages = try await fetchImagesFromServer(for: clothingId)

        // ÂÖÉ„ÅÆÁîªÂÉèID„Å´‰∏ÄËá¥„Åô„ÇãÁîªÂÉè„ÇíÊé¢„Åô„Åü„ÇÅ„ÅÆ„É´„Éº„Éó
        for enrichedImage in allImages {
          // UUID„ÇíStringÂûã„Å´ÊòéÁ§∫ÁöÑ„Å´Â§âÊèõ„Åó„Å¶ÊØîËºÉ
          let enrichedIdString: String = enrichedImage.id.uuidString
          let searchIdString: String = imageId.uuidString
          if enrichedIdString == searchIdString {
            return enrichedImage
          }
        }

        // ‰∏ÄËá¥„Åô„ÇãÁîªÂÉè„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÂÖÉ„ÅÆÁîªÂÉè„ÇíËøî„Åô
        return image
      } catch {
        // Èñ¢ÈÄ£ÁîªÂÉè„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÅØÂÖÉ„ÅÆÁîªÂÉè„ÇíËøî„Åô
        print("Èñ¢ÈÄ£ÁîªÂÉè„ÅÆÂèñÂæó„Å´Â§±Êïó: \(error.localizedDescription)")
        return image
      }
    } catch {
      // APIÂëº„Å≥Âá∫„Åó„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà
      print("ÁîªÂÉè„ÅÆÂèñÂæó„Å´Â§±Êïó: \(error.localizedDescription)")
      throw error
    }
  }
}
